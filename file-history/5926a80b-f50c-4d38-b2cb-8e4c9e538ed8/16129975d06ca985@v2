# MappingFlow - CLAUDE.md

Mapping Flow to funkcja umożliwiająca mapowanie półek sklepowych poprzez tworzenie przejść (aisles) i modułów (modules), a następnie przechwytywanie ich zdjęć w celu późniejszego przesłania do serwera.

## Struktura Folderów

```
MappingFlow/
├── MappingFlowStore.swift              # Root reducer - koordynuje cały flow
├── MappingFlowRootView.swift           # Root view - nawigacja między ekranami
├── MappingFlowRootUseCase.swift        # Use case - factory dla CameraViewModel
├── MappingFlowFirebaseEvent.swift      # Firebase analytics events
├── CaptureView/                        # Ekran przechwytywania zdjęć
│   ├── MappingCaptureFeature.swift     # Feature - capture logic
│   └── MappingCaptureView.swift        # View - camera UI + controls
├── Preview/                            # Ekran podglądu i zatwierdzania
│   ├── MappingPreviewFeature.swift     # Feature - preview logic
│   └── MappingPreviewView.swift        # View - image preview UI
└── ModuleList/                         # Ekran listy modułów
    ├── MappingModuleListFeature.swift  # Feature - module list logic
    ├── MappingModuleListUseCase.swift  # Use case - feature flags
    ├── MappingModuleListView.swift     # View - module list UI
    └── EditAisleName/                  # Sub-feature do edycji nazwy aisle
        ├── MappingModuleListEditAisleNameFeature.swift
        ├── MappingModuleListEditAisleNameUseCase.swift
        ├── MappingModuleListEditAisleNameNetworkRepository.swift
        └── MappingModuleListEditAisleNameView.swift
```

## Flow Navigation

```
AisleListView (zewnętrzny komponent)
    ↓ onAisleSelected
MappingModuleListView (.aisleModuleListView)
    ↓ onModuleCreated / onModuleSelected
MappingCaptureView (.selectedModuleView)
    ↓ capture + approve
MappingPreviewView (sheet)
    ↓ approve → upload → pop back
```

**Nawigacja:**
- Root view używa `NavigationDestination.self` dla child views
- Push destinations: `.aisleModuleListView`, `.selectedModuleView`
- Preview pokazywany jako `.sheet()` z `MappingPreviewFeature.State` jako `Identifiable`

## Architektura i TCA Features

### 1. MappingFlowStore (Root Coordinator)

**Odpowiedzialność:**
- Koordynacja między trzema głównymi feature'ami: `AisleListViewFeature`, `MappingModuleListFeature`, `MappingCaptureFeature`
- Zarządzanie stanem `UpdateFlowCameraViewModel` (współdzielony między ModuleList i Capture)
- Obsługa nawigacji przez `@Dependency(\.homeNavigation)`
- Logowanie analytics przez `@Dependency(\.firebaseAnalytics)`
- Wyświetlanie toastów dla błędów tworzenia aisle

**State:**
```swift
struct State: Equatable {
    var aisleList: AisleListViewFeature.State         // Zawsze obecny
    var moduleList: MappingModuleListFeature.State?   // Optional - przy wyborze aisle
    var capture: MappingCaptureFeature.State?         // Optional - przy capture
    var toastMessage: ToastMessage?
    var cameraViewModel: UpdateFlowCameraViewModel?   // Współdzielony
}
```

**Kluczowe Actions:**
- `.aisleList(.onAisleSelected)` → inicjalizuje `moduleList` + push
- `.moduleList(.list(.onModuleCreated/onModuleSelected))` → inicjalizuje `capture` + push
- `.moduleList(.list(.onInit))` → tworzy i startuje `cameraViewModel`
- `.moduleList(.list(.onDeinit))` → stopuje i czyści `cameraViewModel`
- `.capture(.finalizeModule)` → jeśli nie retaking, wywołuje `.createNewModule`

**Dependency Injection:**
- `MappingFlowRootUseCase` - dependency przez constructor (nie `@Dependency`)
- `ShelfScanCaptureExportOptions` - dependency przez constructor

**⚠️ Ważne wzorce:**
1. **Camera Lifecycle**: `cameraViewModel` jest tworzony w `.moduleList(.list(.onInit))` i niszczony w `.onDeinit` - nie w `onAppear/onDisappear`!
2. **Capture State Reuse**: Metoda `updateCaptureState()` sprawdza czy `state.capture` już istnieje - jeśli tak, tylko aktualizuje moduł zamiast tworzyć nowy state
3. **Retaking Flow**: `isRetaking` boolean kontroluje czy po approve następuje pop (retaking) czy tworzenie nowego modułu (new capture)

---

### 2. MappingModuleListFeature

**Odpowiedzialność:**
- Wyświetlanie listy modułów dla wybranego aisle
- Edycja nazwy aisle (sub-feature `EditAisleNameFeature`)
- Delegowanie logiki do `AisleModuleListFeature` (zewnętrzny współdzielony komponent)

**State:**
```swift
struct State: Equatable {
    @Presents var editAisleName: MappingModuleListEditAisleNameFeature.State?
    var list: AisleModuleListFeature.State  // Delegowany state
    var toast: ToastMessage?

    var aisle: PersistedShelfScanAisle { list.aisle }
    var name: String { list.aisleName }
}
```

**Kluczowe Actions:**
- `.onEditAisleNameButtonTapped` → pokazuje sheet do edycji nazwy
- `.editAisleName(.presented(.handleSuccessfulUpdate))` → aktualizuje lokalny state + toast + propaguje do parent (`.aisleList(.onRefresh)`)
- `.list(AisleModuleListFeature.Action)` → delegacja do child feature

**Dependencies:**
- `AnyMappingModuleListUseCase` - tylko do sprawdzania feature flags (`isNamingConventionGuideEnabled`)

**Composition Pattern:**
```swift
.ifLet(\.$editAisleName, action: \.editAisleName) {
    MappingModuleListEditAisleNameFeature()
}
Scope(state: \.list, action: \.list) {
    AisleModuleListFeature()
}
```

---

### 3. MappingModuleListEditAisleNameFeature (Sub-Feature)

**Odpowiedzialność:**
- Edycja nazwy aisle z walidacją (nie może być pusta, musi się różnić od oryginału)
- Synchronizacja z serwerem i lokalnym DB
- Wyświetlanie toastów dla błędów

**State:**
```swift
struct State: Equatable {
    let aisle: PersistedShelfScanAisle
    let isNamingConventionGuideEnabled: Bool

    var originalAisleName: String { aisle.name }
    var editedAisleName: String
    var isSaveDisabled: Bool  // Computed - empty lub unchanged
    var isUpdating: Bool
    var toast: ToastMessage?
}
```

**Kluczowe Actions:**
- `.onSaveTapped` → async update przez use case
- `.handleSuccessfulUpdate(name:)` → parent zamyka sheet i odświeża listę
- `.handleError` → wyświetla toast z błędem

**Use Case Pattern:**
```swift
protocol AnyMappingModuleListEditAisleNameUseCase {
    func updateAisle(name: String, aisle: PersistedShelfScanAisle) async throws
}
```

**Implementacja:**
1. Wywołuje `networkRepository.updateAisle()` (API call)
2. Aktualizuje lokalnie przez `localAislesRepository.updateAisle()`
3. Błędy są propagowane jako `Error` z `.genericError?.errorMessage`

**Dependencies:**
- `@Dependency(\.localAislesRepository)` - local DB update
- `@Dependency(\.storeRepository)` - store context
- `MappingModuleListEditAisleNameNetworkRepository` - constructor dependency (nie `@Dependency`)

---

### 4. MappingCaptureFeature

**Odpowiedzialność:**
- Przechwytywanie zdjęć półki przez `UpdateFlowCameraViewModel`
- Przełączanie typu kamery (ultra-wide, wide)
- Upload zdjęcia do API + persystencja modułu w DB
- Wyświetlanie guidancea dla użytkownika
- Zarządzanie preview jako child feature

**State:**
```swift
struct State: Equatable {
    var preview: MappingPreviewFeature.State?  // Child feature - jako sheet

    var module: ShelfScanModule
    var isCapturing: Bool
    var loadingSpinner: LoadingSpinnerModel?

    let cameraViewModel: UpdateFlowCameraViewModel  // Shared z MappingFlowStore
    let aisle: PersistedShelfScanAisle
    let isRetaking: Bool
    var isShowingGuidance: Bool
    var isUploadingModule: Bool
    var selectedCameraType: DeviceCameraType
}
```

**Kluczowe Actions:**
- `.onAppear` → analytics + guidance check + `.subscribeToCamera`
- `.subscribeToCamera` → łączy publishers: `$isCapturing` + `imagePublisher`
- `.onShutterButtonTapped` → `cameraViewModel.capture()`
- `.handleCapturedImage` → tworzy `preview` state + pokazuje sheet
- `.preview(.onApproveButtonTapped)` → async upload flow
- `.onCameraTypeTapped` → przełącza typ kamery

**Upload Flow (Action: `.preview(.onApproveButtonTapped)`):**
```swift
1. Sprawdza guard na isUploadingModule (zapobiega multiple taps)
2. Konwertuje UIImage do Data przez exportOptions.data(from:)
3. Persystuje moduł lokalnie: aisleService.persist(module:)
4. Upload do API: httpService.upload(endpoint: UploadModuleImageEndpoint)
5. Wywołuje .finalizeModule (pop jeśli retaking, clear preview jeśli new)
6. Error handling dla wszystkich typów błędów (MappingCaptureFeatureError)
7. Zawsze wywołuje .uploadingFinished (cleanup flag)
```

**⚠️ CRITICAL - Publishers Pattern:**
```swift
case .subscribeToCamera:
    let isCapturingPublisher = state.cameraViewModel.$isCapturing
        .map { Action.updateCaptureState($0) }
    let capturedImagePublisher = state.cameraViewModel.imagePublisher
        .map { Action.handleCapturedImage($0) }

    return .publisher {
        isCapturingPublisher.merge(with: capturedImagePublisher)
    }
    .cancellable(id: Cancel.camera)

case .viewDisappeared:
    return .cancel(id: Cancel.camera)  // ZAWSZE cancel publishers!
```

**Dependencies:**
- `@Dependency(\.homeNavigation)` - nawigacja
- `@Dependency(\.uploadService)` - (obecnie nieużywane, legacy)
- `@Dependency(\.httpService)` - upload image
- `@Dependency(\.firebaseAnalytics)` - analytics
- `@Dependency(\.userGuideDisplayHistory)` - guidance tracking
- `@Dependency(\.aisleService)` - persist module
- `@Dependency(\.apiTokenProvider)` - token dla API
- `ShelfScanCaptureExportOptions` - constructor dependency

**Error Handling:**
```swift
enum MappingCaptureFeatureError: Error {
    case missingToken
    case invalidImageData
    case createModuleFailed(AisleServiceError)
    case uploadFailed(APIRequestError)
    case unexpectedResponse(APIResponseError)
    case unhandledError(Error)
}
```

---

### 5. MappingPreviewFeature

**Odpowiedzialność:**
- Wyświetlanie podglądu zrobionego zdjęcia
- Approve/Retake buttons
- Toast notifications dla błędów uploadu
- Loading spinner podczas uploadu

**State:**
```swift
struct State: Equatable, Identifiable {
    var id: UIImage { image }  // Identifiable dla .sheet(item:)
    let title: String
    let image: UIImage
    var loadingSpinner: LoadingSpinnerModel?
    var toast: ToastMessage?
}
```

**Kluczowe Actions:**
- `.onApproveButtonTapped` → handled przez parent (MappingCaptureFeature)
- `.onRetakeButtonTapped` → handled przez parent (MappingCaptureFeature)
- `.showToast(_:)` → wywoływany z parent przy błędach
- `.dismissToast` → automatyczne po timeout

**⚠️ Ważne:**
- Ten feature NIE obsługuje approve/retake logic - tylko przekazuje action do parenta
- Parent (MappingCaptureFeature) odpowiada za upload i cleanup

---

## Współdzielone Komponenty (External Dependencies)

### AisleListViewFeature
- Zewnętrzny współdzielony komponent z `DigitalShelf/Screens/ShelfScan/Common/AisleList/`
- Wyświetla listę aisles dla danego sklepu
- Actions: `.onAisleSelected(aisle)`, `.onRefresh`, `.addAisle`, `.aisleCreationError`

### AisleModuleListFeature
- Zewnętrzny współdzielony komponent z `DigitalShelf/Screens/ShelfScan/Common/ModuleList/`
- Wyświetla listę modułów dla danego aisle + umożliwia tworzenie nowych
- Actions: `.onModuleSelected(aisle, module)`, `.onModuleCreated(aisle, module)`, `.createNewModule`, `.onInit`, `.onDeinit`

### UpdateFlowCameraViewModel
- Współdzielony camera view model z `DigitalShelf/Screens/ShelfScan/UpdateFlow/Capture/Camera/`
- Zarządza AVCaptureSession, przechwytywanie zdjęć, przełączanie kamer
- Publishers: `@Published var isCapturing: Bool`, `imagePublisher: AnyPublisher<UIImage, Never>`
- Methods: `capture()`, `onAppear()`, `onDisappear()`, `update(cameraType:)`

---

## Kluczowe Wzorce i Best Practices

### 1. Camera Lifecycle Management
```swift
// MappingFlowStore
case .moduleList(.list(.onInit)):
    if state.cameraViewModel.isNil {
        state.cameraViewModel = useCase.makeCameraViewModel()
    }
    state.cameraViewModel?.onAppear()
    return .none

case .moduleList(.list(.onDeinit)):
    state.cameraViewModel?.onDisappear()
    state.cameraViewModel = nil
    return .none
```

**⚠️ Nie w onAppear/onDisappear view!** - Camera musi być inicjalizowana gdy `AisleModuleListFeature` się pojawia, nie przy każdym onAppear `MappingModuleListView`.

### 2. Publisher Subscription Pattern
```swift
// ZAWSZE używaj tego wzorca w TCA:
case .subscribeToCamera:
    let publisher1 = state.dependency.$property.map { Action.update($0) }
    let publisher2 = state.dependency.publisher.map { Action.handle($0) }

    return .publisher {
        publisher1.merge(with: publisher2)
    }
    .cancellable(id: CancelID.subscription)

case .viewDisappeared:
    return .cancel(id: CancelID.subscription)
```

### 3. Dependency Injection Patterns

**TCA `@Dependency` (preferowane dla singletonów/services):**
```swift
@Dependency(\.homeNavigation) var navigation
@Dependency(\.firebaseAnalytics) var analytics
```

**Constructor Dependency (dla custom instances/factory objects):**
```swift
@Reducer
struct MappingFlowStore {
    let useCase: MappingFlowRootUseCase
    let exportOptions: ShelfScanCaptureExportOptions
}
```

**makeWithDeps Factory (dla testów z @Dependency):**
```swift
#if DEBUG
extension UseCase {
    static func makeWithDeps(
        repository: Repository
    ) -> UseCase {
        withDependencies {
            $0.repository = repository
        } operation: { UseCase() }
    }
}
#endif
```

### 4. Error Propagation Pattern
```swift
// Use Case
protocol AnyUseCase {
    func doWork() async throws
}

// Feature
case .doWork:
    return .run { send in
        do {
            try await useCase.doWork()
            await send(.success)
        } catch let error as SpecificError {
            await send(.failed(.specific(error)))
        } catch {
            await send(.failed(.unhandled(error)))
        }
    }

case .failed(let error):
    state.toast = .error(error.localizedDescription)
    return .none
```

### 5. Sheet Presentation z TCA
```swift
// State jako Identifiable
struct State: Equatable, Identifiable {
    var id: UIImage { image }
    let image: UIImage
}

// View
.sheet(item: store.binding(keyPath: \.preview)) { _ in
    store.optionalScope(
        state: \.preview,
        action: \.preview,
        view: MappingPreviewView.init
    )
}
```

### 6. Reducer Composition Order
```swift
var body: some ReducerOf<Self> {
    Reduce { state, action in /* main logic */ }
    .ifLet(\.preview, action: \.preview) { MappingPreviewFeature() }
    Scope(state: \.list, action: \.list) { AisleModuleListFeature() }
}
```

---

## Typowe Błędy i Pitfalls

### ❌ NIE rób tego:
```swift
// 1. Accessing @Dependency in TaskGroup
@Dependency(\.apiClient) var apiClient
withThrowingTaskGroup { group in
    group.addTask { try await self.apiClient.fetch() }  // CRASH!
}

// 2. Zapominanie cancel publishers
case .onDisappear:
    return .none  // ❌ Publishers dalej działają!

// 3. Wielokrotne handleSuccessfulUpdate
case .preview(.onApproveButtonTapped):
    // ... upload logic
    return .send(.finalizeModule)  // ❌ Brak guard na isUploadingModule!
```

### ✅ Zrób to:
```swift
// 1. Capture dependency before TaskGroup
let apiClient = self.apiClient
withThrowingTaskGroup { group in
    group.addTask { try await apiClient.fetch() }
}

// 2. ZAWSZE cancel publishers
case .onDisappear:
    return .cancel(id: Cancel.camera)

// 3. Guard przed async operations
case .preview(.onApproveButtonTapped) where !state.isUploadingModule:
    state.isUploadingModule = true
    // ... upload logic
```

---

## Testing Guidelines

### Presentation Layer (TCA Features)
- Mock WSZYSTKIE dependencies (`@Dependency`, use cases, repositories)
- Use `TestStore` z `lazy var` initialization
- Test full user journeys, nie individual actions
- ZAWSZE używaj keypaths: `await sut.receive(\.action)`

**Przykład:**
```swift
lazy var sut = TestStore(
    initialState: MappingCaptureFeature.State(...),
    reducer: { MappingCaptureFeature(exportOptions: mockOptions) }
) {
    $0.homeNavigation = mockNavigation
    $0.aisleService = mockAisleService
    $0.httpService = mockHttpService
    // ... wszystkie dependencies
}

func testApproveFlow() async {
    await sut.send(.preview(.onApproveButtonTapped))
    await sut.receive(\.finalizeModule)
}
```

### Business Layer (Use Cases)
- Używaj REAL repositories, models, business logic
- Mock TYLKO external dependencies (API, FileSystem, DB)
- Test edge cases i error handling

---

## Firebase Analytics Events

```swift
extension MappingFlowFirebaseEvent {
    static let aisleListScreen = make(screenName: "aisle_list")
    static let moduleListScreen = make(screenName: "module_list")
    static let captureCameraScreen = make(screenName: "capture_camera")
    static let uploadScreen = make(screenName: "upload")

    static let newAisleButton = make(buttonName: "new_aisle")
    static let newModuleButton = make(buttonName: "new_module")
    static let shutterButton = make(buttonName: "shutter")
    static let retakeButton = make(buttonName: "retake")
    static let approveButton = make(buttonName: "approve")

    static let aisleSelection = make(optionName: "aisle")
    static let moduleSelection = make(optionName: "module")
}
```

**Usage:**
```swift
analytics.logMappingFlow(event: .captureCameraScreen)  // Screen view
analytics.logMappingFlow(event: .shutterButton)        // Button tap
```

---

## Localization Keys

**Convention:** `L10n.MappingFlow.<Component>.<element>`

```swift
L10n.MappingFlow.List.title                    // "Mapping Flow"
L10n.MappingFlow.List.aisleCreationError       // "Could not create aisle"
L10n.MappingFlow.Capture.capturing             // "Capturing..."
L10n.MappingFlow.Capture.updatingModule        // "Updating module..."
L10n.MappingFlow.Preview.retakeButton          // "Retake"
L10n.MappingFlow.Preview.approveButton         // "Approve"
L10n.MappingFlow.EditAisleName.toastSuccess    // "Aisle name updated"
L10n.MappingFlow.EditAisleName.toastError      // "Could not update aisle name"
```

---

## Podsumowanie Zależności

```
MappingFlowStore
├── MappingFlowRootUseCase (constructor)
│   └── CameraRepository → UpdateFlowCameraViewModel
├── @Dependency(\.homeNavigation)
├── @Dependency(\.firebaseAnalytics)
├── @Dependency(\.aisleService)
└── ShelfScanCaptureExportOptions (constructor)

MappingModuleListFeature
├── AnyMappingModuleListUseCase (constructor, default = MappingModuleListUseCase())
│   └── @Dependency(\.customFeature)
└── AisleModuleListFeature (child scope)

MappingModuleListEditAisleNameFeature
└── AnyMappingModuleListEditAisleNameUseCase (constructor)
    ├── @Dependency(\.localAislesRepository)
    ├── @Dependency(\.storeRepository)
    └── MappingModuleListEditAisleNameNetworkRepository (constructor)

MappingCaptureFeature
├── UpdateFlowCameraViewModel (shared from MappingFlowStore)
├── @Dependency(\.homeNavigation)
├── @Dependency(\.httpService)
├── @Dependency(\.firebaseAnalytics)
├── @Dependency(\.userGuideDisplayHistory)
├── @Dependency(\.aisleService)
├── @Dependency(\.apiTokenProvider)
├── ShelfScanCaptureExportOptions (constructor)
└── MappingPreviewFeature (child ifLet)
```
