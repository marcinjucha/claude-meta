// Copyright Â© 2024 Scandit. All rights reserved.

import ComposableArchitecture

@Reducer
struct MappingModeModulePreviewFeature {
    @ObservableState
    struct State: Equatable {
        let module: ShelfScanModule
        let aisle: PersistedShelfScanAisle
        let isRetaking: Bool

        var moduleImage: Refreshable<UIImage> = .idle

        var title: String {
            "Module \(module.moduleReference)"
        }

        var moduleGroupName: String {
            aisle.name
        }
    }

    enum Action {
        case onAppear
        case onContinueButtonTapped
        case viewDisappeared
        case loadModulePreview
        case refreshImage
        case setModuleImage(Refreshable<UIImage>)
        case analytics(event: MappingFlowFirebaseEvent)
    }

    private enum CancelID {
        case modulePreview
    }

    @Dependency(\.firebaseAnalytics)
    var analytics

    let useCase: AnyMappingModeModulePreviewUseCase

    init(useCase: AnyMappingModeModulePreviewUseCase = MappingModeModulePreviewUseCase()) {
        self.useCase = useCase
    }

    var body: some Reducer<State, Action> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                analytics.logMappingFlow(event: .modulePreviewScreen)
                return .send(.loadModulePreview)

            case .onContinueButtonTapped:
                analytics.logMappingFlow(event: .continueButton)
                return .none

            case .viewDisappeared:
                return .cancel(id: CancelID.modulePreview)

            case .loadModulePreview:
                guard let moduleId = state.module.moduleId else {
                    return .none
                }

                state.moduleImage = .loading

                let useCase = self.useCase

                return .run { send in
                    do {
                        let (cached, freshTask) = try await useCase.loadModulePreview(moduleId: moduleId)

                        // If we have cached image, show it immediately as .refreshing
                        if let cached {
                            await send(.setModuleImage(.refreshing(current: cached)))
                        }

                        // Wait for fresh image
                        let freshImage = try await freshTask.value
                        await send(.setModuleImage(.success(freshImage)))

                    } catch {
                        await send(.setModuleImage(.failure))
                    }
                }
                .cancellable(id: CancelID.modulePreview)

            case .refreshImage:
                guard !state.moduleImage.isLoading else {
                    return .none
                }

                guard let moduleId = state.module.moduleId else {
                    return .none
                }

                // Keep current image visible during refresh if available
                if case let .success(currentImage) = state.moduleImage {
                    state.moduleImage = .refreshing(current: currentImage)
                } else {
                    state.moduleImage = .loading
                }

                let useCase = self.useCase

                return .run { send in
                    do {
                        let (cached, freshTask) = try await useCase.loadModulePreview(moduleId: moduleId)

                        // If we have cached image and currently in .loading state, show cached as .refreshing
                        if let cached = cached {
                            await send(.setModuleImage(.refreshing(current: cached)))
                        }

                        // Wait for fresh image
                        let freshImage = try await freshTask.value
                        await send(.setModuleImage(.success(freshImage)))

                    } catch {
                        await send(.setModuleImage(.failure))
                    }
                }
                .cancellable(id: CancelID.modulePreview)

            case .setModuleImage(let refreshable):
                state.moduleImage = refreshable
                return .none

            case .analytics(let event):
                analytics.logMappingFlow(event: event)
                return .none
            }
        }
    }
}
