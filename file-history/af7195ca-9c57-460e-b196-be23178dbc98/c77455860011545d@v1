// Copyright Â© 2024 Scandit. All rights reserved.

import ComposableArchitecture

@Reducer
struct MappingModeModulePreviewFeature {
    @ObservableState
    struct State: Equatable {
        let module: ShelfScanModule
        let aisle: PersistedShelfScanAisle
        let isRetaking: Bool

        var moduleImage: Refreshable<UIImage> = .idle

        var title: String {
            "Module \(aisle.name) - \(module.moduleReference)"
        }

        var moduleGroupName: String {
            aisle.name
        }
    }

    enum Action {
        case onAppear
        case onContinueButtonTapped
        case viewDisappeared
        case loadModulePreview
        case refreshImage
        case setModuleImage(Refreshable<UIImage>)
        case analytics(event: MappingFlowFirebaseEvent)
    }

    private enum CancelID {
        case modulePreview
    }

    @Dependency(\.firebaseAnalytics)
    var analytics

    @Dependency(\.modulePreviewRepository)
    private var previewRepository: ModulePreviewRepository

    var body: some Reducer<State, Action> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                analytics.logMappingFlow(event: .modulePreviewScreen)
                return .send(.loadModulePreview)

            case .onContinueButtonTapped:
                analytics.logMappingFlow(event: .continueButton)
                return .none

            case .viewDisappeared:
                return .cancel(id: CancelID.modulePreview)

            case .loadModulePreview:
                guard let moduleId = state.module.moduleId else {
                    return .none
                }

                state.moduleImage = .loading

                let previewRepository = self.previewRepository

                return .run { send in
                    let helper = ModulePreviewHelper(
                        previewRepository: previewRepository,
                        ignoreOfflineStatus: true
                    )

                    await helper.reloadPreview(
                        moduleId: moduleId,
                        onStatusUpdated: { image in
                            await send(.setModuleImage(image))
                        }
                    )
                }
                .cancellable(id: CancelID.modulePreview)

            case .refreshImage:
                guard !state.moduleImage.isLoading else {
                    return .none
                }

                guard let moduleId = state.module.moduleId else {
                    return .none
                }

                // Keep current image visible during refresh if available
                if case .success = state.moduleImage {
                    // Image will transition to .refreshing in the helper's callback
                } else {
                    state.moduleImage = .loading
                }

                let previewRepository = self.previewRepository

                return .run { send in
                    let helper = ModulePreviewHelper(
                        previewRepository: previewRepository,
                        ignoreOfflineStatus: true
                    )

                    await helper.reloadPreview(
                        moduleId: moduleId,
                        onStatusUpdated: { image in
                            await send(.setModuleImage(image))
                        }
                    )
                }
                .cancellable(id: CancelID.modulePreview)

            case .setModuleImage(let refreshable):
                state.moduleImage = refreshable
                return .none

            case .analytics(let event):
                analytics.logMappingFlow(event: event)
                return .none
            }
        }
    }
}
