---
description: Step-by-step guide for planning and building features - from idea to implementation with code organization and testing
---
# Feature Planning & Implementation Guide

## üîë Keywords & Usage

**Use this rule when you write:**
- "plan feature", "new feature", "start feature"
- "how to implement", "feature design"
- "architecture plan", "implementation steps"
- "what layers do I need", "testing strategy"
- "feature template", "checklist"

**Example prompts:**
- "I want to implement a new user settings feature"
- "Help me plan the route filtering feature"
- "What layers do I need for offline sync?"
- "Create implementation plan for notifications"
- "Step-by-step guide for building search feature"

---

## üéØ Purpose
This guide provides a structured, actionable approach to planning and implementing features in Digital Shelf iOS. Follow this process to ensure architectural consistency, testability, and maintainability from the start.

---

## üìã Phase 1: Feature Analysis & Planning

### Step 1: Understand the Business Requirements
**Questions to Answer:**
- What user problem does this feature solve?
- What data does the feature need? (Models, API endpoints, database tables)
- What user interactions are required? (Buttons, forms, navigation flows)
- What are the edge cases? (Offline, errors, empty states)
- What are the performance constraints? (Real-time updates, background processing)

**Output**: Written feature specification with user stories and acceptance criteria.

---

### Step 2: Identify Architecture Layers

**Decision Process (Answer These Questions):**

1. **Do I need new data structures?**
   - YES ‚Üí Create Models
   - NO ‚Üí Use existing models

2. **Where does data come from?**
   - Database ‚Üí Create Data Repository
   - API ‚Üí Create Network Repository
   - Shared state ‚Üí Create Shared Repository
   - Multiple sources ‚Üí Create Service (next step)

3. **Do I need to combine multiple repositories?**
   - YES ‚Üí Create Service
   - NO ‚Üí Skip Service, go to Use Case

4. **Is there complex business logic?**
   - YES ‚Üí Create Service (if not already)
   - NO ‚Üí Use Case will be thin

5. **Do I need UI + state management?**
   - YES ‚Üí Create TCA Feature + View
   - Always YES for user-facing features

**For EACH piece of functionality, decide which layers you need:**

#### Models Layer (Always Required)
- **Purpose**: Domain entities that represent business concepts
- **Decision Criteria**: Do you need new data structures or can you reuse existing models?
- **Examples**: `Route`, `User`, `Store`, `UploadStatus`
- **File Location**: `DigitalShelf/Models/`

#### Repository Layer (Data Access)
- **Purpose**: Single-responsibility data access (database OR network OR cache)
- **Decision Criteria**:
  - Need database CRUD operations? ‚Üí **Data Repository**
  - Need API calls? ‚Üí **Network Repository**
  - Need shared state across features? ‚Üí **Shared Repository**
- **Critical Rule**: Repositories NEVER depend on other repositories (prevents cycles)
- **File Location**: `DigitalShelf/Screens/[Feature]/Repository/`

#### Service Layer (Business Logic with Multiple Data Sources)
- **Purpose**: Combines multiple repositories OR complex domain algorithms
- **Decision Criteria**:
  - Combining 2+ repositories? ‚Üí **Service** (prevents repository cycles)
  - Complex business algorithm (badge calculation, data fusion)? ‚Üí **Service**
  - Single data source with simple logic? ‚Üí Skip, use Use Case directly
- **Examples**: `RouteWithHistoryService` (5 repos), `HomeModeService` (3 repos)
- **File Location**: `DigitalShelf/Services/[Feature]/`

#### Use Case Layer (Orchestration)
- **Purpose**: Thin orchestration layer between Presentation and Business logic
- **Decision Criteria**: Always create for feature coordination
- **Responsibilities**:
  - Delegate to Services/Repositories
  - Expose publishers for reactive data
  - NO complex algorithms (belongs in Service)
- **File Location**: `DigitalShelf/Screens/[Feature]/Use Case/`

#### Presentation Layer (TCA + SwiftUI)
- **Purpose**: User interface and reactive state management
- **Components Required**:
  - **Feature Store** (TCA Reducer): State + Actions + Business logic coordination
  - **View**: SwiftUI layout + Store binding
- **File Location**: `DigitalShelf/Screens/[Feature]/Presentation/`

---

### Step 3: Design State & Actions (TCA)

#### State Design Checklist
```swift
@ObservableState
struct State: Equatable {
    // ‚úÖ Data properties (loaded from Use Case)
    var items: [Item] = []

    // ‚úÖ UI state (loading, errors, selections)
    var isLoading = false
    var errorMessage: String?
    var selectedItemId: Item.ID?

    // ‚úÖ Child features (optional/conditional)
    @Presents var alert: AlertState<Action.Alert>?
    @Presents var sheet: ChildFeature.State?

    // ‚úÖ Computed properties for derived state
    var selectedItem: Item? {
        items.first(where: { $0.id == selectedItemId })
    }
}
```

**State Design Questions:**
- What data needs to be displayed? ‚Üí Data properties
- What UI controls need state? ‚Üí UI state properties
- Are there child features or alerts? ‚Üí Use `@Presents`
- Can any state be computed from other state? ‚Üí Use computed properties

#### Action Design Checklist
```swift
enum Action {
    // ‚úÖ User interactions
    case viewAppeared
    case itemTapped(Item.ID)
    case refreshButtonTapped

    // ‚úÖ System/async responses
    case itemsLoaded([Item])
    case loadingFailed(String)

    // ‚úÖ Publisher updates
    case itemsUpdated([Item])
    case networkStatusChanged(NetworkStatus)

    // ‚úÖ Navigation/delegation (if needed)
    case delegate(DelegateAction)

    // ‚úÖ Child features
    case alert(PresentationAction<Alert>)
    case sheet(PresentationAction<ChildFeature.Action>)

    enum Alert: Equatable {}
    enum DelegateAction {
        case itemSelected(Item)
    }
}
```

**Action Categories:**
1. **View lifecycle**: `viewAppeared`, `viewDisappeared`
2. **User interactions**: Button taps, text input, selections
3. **Async responses**: Success/failure from API calls, database operations
4. **Publisher updates**: Real-time data changes
5. **Child actions**: For nested TCA features

---

### Step 4: Design Data Flow & Publishers

**For each data source, decide on update strategy:**

#### Real-Time Data (Use Publishers)
- **When**: Data changes frequently or from external sources (database, store changes, network)
- **Pattern**: Subscribe in `initialize` or `onAppear`, cancel in `onDisappear`
- **Example**: Routes list updates when new captures are uploaded
```swift
case .onAppear:
    return .publisher {
        useCase.routesPublisher.map(Action.itemsUpdated)
    }
    .cancellable(id: CancelID.items)
```

#### One-Time Data Load (Use Effects)
- **When**: Data loaded once on demand (fetch user profile, download file)
- **Pattern**: Use `.run` effect with success/failure handling
```swift
case .loadData:
    state.isLoading = true
    return .run { send in
        do {
            let data = try await useCase.fetchData()
            await send(.dataLoaded(data))
        } catch {
            await send(.loadingFailed(error.localizedDescription))
        }
    }
```

#### Combining Multiple Publishers
- **When**: UI needs data from multiple sources simultaneously
- **Pattern**: Use `.merge()` or `combineLatest` in Use Case
- **Critical**: Each publisher needs unique `CancelID`

---

### Step 5: Plan Testing Strategy

#### Presentation Tests (TCA Logic)
**Purpose**: Test state transitions, action handling, UI behavior

**Setup Pattern:**
```swift
@MainActor
final class FeatureStoreTests: XCTestCase {
    let useCase = FeatureUseCaseSpy() // Mock

    lazy var sut = TestStoreOf<FeatureStore>(
        initialState: FeatureStore.State()
    ) {
        FeatureStore(useCase: useCase)
    }
}
```

**What to Test:**
- [ ] Initial state is correct
- [ ] User actions trigger correct state changes
- [ ] Publisher subscriptions work correctly
- [ ] Error handling updates state properly
- [ ] Navigation/delegation actions are sent

**What to Mock**: ALL dependencies (UseCases, Navigation, External Services)

#### Business Integration Tests (Use Case + Service)
**Purpose**: Test data flow between layers with real components

**Setup Pattern:**
```swift
final class FeatureUseCaseTests: XCTestCase {
    let database = ShelfDatabase.inMemory() // Real
    lazy var dataRepository = DataRepository.makeWithDeps(database: database)
    lazy var sut = FeatureUseCase.makeWithDeps(
        dataRepository: dataRepository
    )
}
```

**What to Test:**
- [ ] Publishers emit correct data from repositories
- [ ] Data transformations work correctly
- [ ] Service combines multiple repositories properly
- [ ] Error propagation from repositories to Use Case

**What to Mock**: ONLY external dependencies (APIs, FileSystem, Timers)

---

## üõ†Ô∏è Phase 2: Implementation Execution

### Implementation Order (Follow This Sequence)

#### 1. Models First
- [ ] Define domain models with `Equatable`, `Codable` as needed
- [ ] Add sample data for testing (`extension Model { static func sample() }`)

#### 2. Repositories Next
- [ ] Create protocol first (`protocol AnyFeatureRepository`)
- [ ] Implement repository with `@Dependency` injection
- [ ] Add `makeWithDeps` factory method for tests (wrapped in `#if DEBUG`)
- [ ] Write repository tests (if complex logic exists)

#### 3. Services (If Needed)
- [ ] Create protocol (`protocol AnyFeatureService`)
- [ ] Implement service combining repositories
- [ ] Add `makeWithDeps` factory method
- [ ] Write service tests for complex algorithms

#### 4. Use Case
- [ ] Create protocol (`protocol AnyFeatureUseCase`)
- [ ] Implement Use Case with publisher properties
- [ ] Delegate to Services/Repositories (no complex logic here)
- [ ] Add `makeWithDeps` factory method
- [ ] Write business integration tests

#### 5. TCA Feature Store
- [ ] Define `State` struct with `@ObservableState`
- [ ] Define `Action` enum
- [ ] Implement reducer body:
  1. `BindingReducer()` first (if using bindings)
  2. `Scope()` for child features
  3. `Reduce { state, action in ... }` for main logic
- [ ] Write presentation tests with mocked Use Case

#### 6. SwiftUI View
- [ ] Create view with `@Bindable var store: StoreOf<FeatureStore>`
- [ ] Bind UI elements to store state
- [ ] Send actions for user interactions
- [ ] Add `.onAppear { store.send(.viewAppeared) }`

#### 7. Navigation Integration
- [ ] Register navigation destination in parent view
- [ ] Test navigation flow

---

### Critical Implementation Checkpoints

#### ‚úÖ Before Writing Code
- [ ] Architecture layers identified (Models, Repo, Service, UseCase, TCA)
- [ ] State & Actions designed (written in comments or scratch file)
- [ ] Data flow mapped (publishers vs effects)
- [ ] Testing strategy planned (what to mock, what to use real)

#### ‚úÖ During Implementation
- [ ] `@ObservableState` on all State structs
- [ ] `BindingReducer()` first in reducer body
- [ ] Individual `CancelID` for each publisher
- [ ] `makeWithDeps` factory for all components with `@Dependency`
- [ ] Capture `@Dependency` before TaskGroup (if using TaskGroup)
- [ ] Use `weakSink` for publisher subscriptions (memory safety)

#### ‚úÖ Before Committing
- [ ] All tests passing (presentation + business integration)
- [ ] No obvious comments (only complex algorithms need explanation)
- [ ] No unused imports or variables
- [ ] File organization correct (static ‚Üí properties ‚Üí lifecycle ‚Üí methods)
- [ ] Localized strings use `L10n` constants (no hardcoded text)
- [ ] SwiftLint warnings resolved
- [ ] Navigation working correctly

---

## üö® Common Decision Points

### When to Use Service vs Use Case?
**Use Service When:**
- Combining 2+ repositories (prevents dependency cycles)
- Complex business algorithm (badge calculation, data fusion, filtering)
- Domain-specific logic that's reused across multiple Use Cases

**Use Use Case When:**
- Simple orchestration/delegation
- Exposing publishers to TCA layer
- Coordinating Services without complex logic

**Example Decision Tree:**
```
Need data?
‚îú‚îÄ Single source (DB or API) ‚Üí Repository
‚îú‚îÄ Multiple sources ‚Üí Service
‚îî‚îÄ Orchestration only ‚Üí Use Case
```

### When to Use Publishers vs Effects?
**Use Publishers:**
- Data changes over time (database updates, store changes, network status)
- Subscribe in `initialize` or `onAppear`
- Cancel in `onDisappear` or when no longer needed

**Use Effects (`.run`):**
- One-time operations (API calls, file downloads)
- User-triggered actions (button tap ‚Üí fetch data)
- Operations with explicit success/failure

### When to Create Child TCA Feature?
**Create Child Feature When:**
- Complex isolated UI component (modal, complex form)
- Reusable across multiple parent features
- Has its own state lifecycle independent of parent

**Keep in Parent When:**
- Simple UI (alerts, confirmation dialogs)
- Tightly coupled to parent state
- No reuse needed

---

## üìù Feature Planning Template

Use this template when starting a new feature:

```
# Feature: [Feature Name]

## Business Requirements
- User story: As a [role], I want [goal] so that [benefit]
- Acceptance criteria:
  - [ ] Criterion 1
  - [ ] Criterion 2

## Architecture Plan

### Models
- [ ] New models needed: [Model names]
- [ ] Existing models to modify: [Model names]

### Data Layer
- [ ] Data Repository: [Yes/No - describe purpose]
- [ ] Network Repository: [Yes/No - describe purpose]
- [ ] Shared Repository: [Yes/No - describe purpose]

### Business Layer
- [ ] Service: [Yes/No - describe purpose]
- [ ] Use Case: [Yes/No - describe purpose]

### Presentation Layer
- [ ] TCA Feature Store: [Feature name]
- [ ] SwiftUI Views: [View names]
- [ ] Child features: [If any]

## State Design
```swift
@ObservableState
struct State: Equatable {
    // TODO: Define state properties
}
```

## Action Design
```swift
enum Action {
    // TODO: Define actions
}
```

## Data Flow
- [ ] Publisher 1: [Source ‚Üí Action]
- [ ] Effect 1: [Trigger ‚Üí Operation ‚Üí Result Action]

## Testing Plan
- [ ] Presentation tests: [List test cases]
- [ ] Business integration tests: [List test cases]
- [ ] What to mock: [List]
- [ ] What to use real: [List]

## Implementation Checklist
- [ ] Models with sample data
- [ ] Repositories with makeWithDeps
- [ ] Services with makeWithDeps (if needed)
- [ ] Use Case with makeWithDeps
- [ ] TCA Store with State/Actions/Reducer
- [ ] SwiftUI View with Store binding
- [ ] Presentation tests
- [ ] Business integration tests
- [ ] Navigation integration
- [ ] Localization (L10n constants)
```

---

## üéØ Key Principles Summary

1. **Plan Before Coding**: Understand requirements ‚Üí Design architecture ‚Üí Implement
2. **Layer Separation**: Models ‚Üí Repository ‚Üí Service ‚Üí Use Case ‚Üí Presentation
3. **Dependency Direction**: Higher layers depend on lower layers (never reverse)
4. **Test Strategy**: Mock external dependencies, use real business logic
5. **TCA Patterns**: State drives UI, Actions trigger changes, Reducers transform state
6. **Memory Safety**: Use `weakSink`, cancel subscriptions, capture deps before TaskGroup
7. **Code Quality**: Self-documenting code > comments, meaningful names, organized structure

**Remember: Clarity in planning leads to speed in implementation. Take time to design, then code flows naturally.**
