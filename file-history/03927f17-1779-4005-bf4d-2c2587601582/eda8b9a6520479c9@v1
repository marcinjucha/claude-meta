---
description: Presentation layer testing - view testing, state testing, user interaction testing, async testing, and common test pitfalls
globs: *Tests.swift,*Test.swift
---

# Presentation Layer Testing - Best Practices & Pitfalls

## ğŸ”‘ Keywords & Usage

**This rule automatically applies in test files (*Tests.swift), but you can use it when you write:**
- "test", "testing", "test this feature"
- "test view", "test screen", "test presentation"
- "mock", "spy", "test double"
- "test async", "test publisher", "test loading"
- "test user interaction", "test button tap"
- "test failure", "test error", "debug test"

**Example prompts:**
- "Write tests for this feature"
- "Test loading state behavior"
- "Test button tap with async operation"
- "Create test spy for use case"
- "Test error handling in view"
- "Debug failing test"

---

## ğŸš¨ Critical Pitfalls to Avoid

### âŒ NEVER: Use `skipInFlightEffects()` When No Effects Exist
```swift
// âŒ WRONG - Will cause "There were no in-flight effects to skip" error
await sut.send(.simpleAction) // No async effects
await sut.skipInFlightEffects() // âŒ ERROR - no effects to skip

// âœ… CORRECT - Only use when effects actually exist
await sut.send(.onAppear) // Has publisher subscriptions
await sut.skipInFlightEffects() // âœ… OK - effects exist
```

### âŒ NEVER: Ignore Unhandled Actions
```swift
// âŒ WRONG - Will cause test failures
await sut.send(.initialize) // Triggers multiple async actions but we ignore them

// âœ… CORRECT - Handle ALL resulting actions
await sut.send(.initialize) {
    $0.isLoaded = true
}
await sut.receive(\.reloadList)
await sut.receive(\.setupPublishers)
// OR use skipInFlightEffects() if effects exist but aren't relevant to test
```

### âŒ NEVER: Missing Dependencies in Tests
```swift
// âŒ WRONG - Will crash with "no test implementation" error
TestStore(initialState: Feature.State()) {
    Feature() // Uses @Dependency without mocking
}

// âœ… CORRECT - Mock all dependencies
TestStore(initialState: Feature.State()) {
    Feature()
} withDependencies: {
    $0.routeNavigation = NavigationMock()
    $0.uuid = .constant(UUID())
}
```

### âŒ NEVER: Initialize TestStore in setUp()
```swift
// âŒ WRONG - Don't initialize in setUp()
override func setUp() {
    sut = TestStore(...) // âŒ Use lazy var instead
}

// âœ… CORRECT - Use lazy var
lazy var sut = TestStoreOf<Feature>(initialState: Feature.State()) {
    Feature(useCase: useCase)
}
```

### âŒ NEVER: Test Publisher Timing Without Proper Mocking
```swift
// âŒ WRONG - Real publishers cause timing issues in tests
let realUseCase = RouteListUseCase() // Real publishers
TestStore(...) { Feature(useCase: realUseCase) }

// âœ… CORRECT - Use spy with controllable publishers
let useCase = RouteListUseCaseSpy() // Controllable subjects
useCase.stubbedRoutesPublisher.send(routes) // Deterministic timing
```

### âŒ NEVER: Ignore Publisher Lifecycle in Tests
```swift
// âŒ WRONG - Missing publisher setup/teardown
await sut.send(.onAppear) // Sets up publishers but we don't handle them
// Test continues without handling publisher effects

// âœ… CORRECT - Handle all publisher effects
await sut.send(.onAppear)
await sut.receive(\.reloadList) // Handle immediate effects
// Then trigger publisher emissions
useCase.stubbedRoutesPublisher.send(routes)
await sut.receive(\.updateRoutes) // Handle publisher effects
```

## ğŸ—ï¸ Essential Patterns

### TestStore Setup
```swift
// âœ… Standard pattern - lazy var with dependencies
@MainActor
final class RouteListFeatureTests: XCTestCase {
    let useCase = RouteListUseCaseSpy()
    lazy var sut = TestStoreOf<RouteListFeature>(initialState: RouteListFeature.State()) {
        RouteListFeature(useCase: useCase)
    }
}

// âœ… With dependencies block
lazy var sut: TestStoreOf<Feature> = .init(
    initialState: Feature.State(),
    reducer: { Feature(useCase: useCase) },
    withDependencies: {
        $0.navigation = NavigationMock()
        $0.uuid = .constant(UUID())
    }
)
```

### Action Handling
```swift
// âœ… ALWAYS use keypaths for receive()
await sut.receive(\.updateRoutes) {
    $0.routes = routes
    $0.showActivityIndicator = false
}

await sut.receive(\.reloadList) // No state changes
await sut.receive(\.navigateToAisle, aisle) // With value

// âœ… Child feature actions (from HomeStore example)
await sut.receive(\.storeSelection, .setup) {
    $0.storeSelection.showActivityIndicator = true
}
await sut.receive(\.storeSelection, .fetchStores)
await sut.receive(\.storeSelection, .dismissErrorMessage) {
    $0.storeSelection.showActivityIndicator = false
}

// âœ… Direct actions for send()
await sut.send(.onAppear) {
    $0.isLoaded = true
}
```

## ğŸ§ª Testing Strategy

### Dual-Layer Approach
```swift
// 1. PRESENTATION LAYER - Mock everything (Fast & Isolated)
@MainActor
final class RouteListFeatureTests: XCTestCase {
    let useCase = RouteListUseCaseSpy() // â† Mocked
    // Test TCA logic, UI behavior, state transitions
}

// 2. BUSINESS LAYER - Real components, mock external only
final class RouteListUseCaseTests: XCTestCase {
    let database = ShelfDatabase.inMemory() // â† Real
    let httpService = FakeHttpService() // â† Mock external
    // Test business logic, data flow, integration
}
```

### Publisher Testing
```swift
func testPublisherSubscription() async {
    await sut.send(.onAppear)
    await sut.receive(\.reloadList)

    // Send data through stubbed publisher
    let routes = [Route.sample()]
    useCase.stubbedRoutesPublisher.send(routes)

    await sut.receive(\.updateRoutes) {
        $0.routes = routes
    }
}

// âœ… Testing Loading State Publishers
func testStoreChangeLoadingState() async {
    await sut.send(.initialize) {
        $0.isLoaded = true
    }
    await sut.receive(\.reloadList)

    // Simulate store change loading start
    useCase.stubbedStoreChangeLoadingState.send(true)
    await sut.receive(\.storeChangeLoadingStateChanged, true) {
        $0.routes = []
        $0.isLoaded = false
        $0.showActivityIndicator = true
    }

    // Simulate loading completion
    useCase.stubbedStoreChangeLoadingState.send(false)
    await sut.receive(\.storeChangeLoadingStateChanged, false)

    // Then routes arrive
    useCase.stubbedRoutesPublisher.send([Route.sample()])
    await sut.receive(\.updateRoutes) {
        $0.routes = [Route.sample()]
        $0.showActivityIndicator = false
    }
}
```

### Test Data Helpers
```swift
// âœ… Deterministic test data
private func makeIncompleteRoute() -> Route {
    Route.sample(aisles: [
        RouteAisle.sample(modules: [
            RouteAisleModule.sample(captured: true),
            RouteAisleModule.sample(captured: false) // Not complete
        ])
    ])
}
```

## ğŸ› Debugging Test Failures

### Common Test Failure Patterns

#### "There were no in-flight effects to skip"
```swift
// âŒ Problem: Using skipInFlightEffects() when no effects exist
await sut.send(.simpleAction)
await sut.skipInFlightEffects() // âŒ No effects to skip

// âœ… Solution: Only use when effects actually exist
await sut.send(.onAppear) // Has publisher subscriptions
await sut.skipInFlightEffects() // âœ… Effects exist
```

#### "Unhandled action received"
```swift
// âŒ Problem: Action triggered but not handled in test
await sut.send(.initialize) // Triggers .reloadList but we don't handle it

// âœ… Solution: Handle all resulting actions
await sut.send(.initialize) {
    $0.isLoaded = true
}
await sut.receive(\.reloadList) // Handle the triggered action
```

#### "Expected state change but none occurred"
```swift
// âŒ Problem: Wrong state expectations
await sut.send(.updateRoutes, routes) {
    $0.isLoading = false // âŒ This property doesn't exist or isn't changed
}

// âœ… Solution: Check actual state changes in reducer
await sut.send(.updateRoutes, routes) {
    $0.routes = routes
    $0.showActivityIndicator = false // âœ… Correct property
}
```

### Debugging Strategies

#### 1. Enable Exhaustive Testing
```swift
// âœ… Add to test setup for detailed failure info
sut.exhaustivity = .on
```

#### 2. Use Print Debugging in Tests
```swift
// âœ… Temporary debugging in tests
await sut.send(.action) {
    print("State before: \($0)")
    $0.property = newValue
    print("State after: \($0)")
}
```

#### 3. Check Publisher Emissions
```swift
// âœ… Verify spy publishers are working
XCTAssertTrue(useCase.stubbedRoutesPublisher.hasSubscribers)
useCase.stubbedRoutesPublisher.send(routes)
// Then check if action is received
```

#### 4. Test Publisher Lifecycle
```swift
// âœ… Test complete publisher lifecycle
func testPublisherLifecycle() async {
    // Setup
    await sut.send(.onAppear)
    await sut.receive(\.reloadList)

    // Emit data
    useCase.stubbedRoutesPublisher.send(routes)
    await sut.receive(\.updateRoutes) { $0.routes = routes }

    // Teardown
    await sut.send(.onDisappear)
    // Verify no more emissions after cancellation
    useCase.stubbedRoutesPublisher.send([])
    // Should not receive updateRoutes action
}
```

## ğŸ“‹ Quick Reference

### âŒ CRITICAL PITFALLS:
- **`skipInFlightEffects()` when no effects exist** â†’ "no in-flight effects to skip" error
- **Ignoring unhandled actions** â†’ Test failures
- **Missing dependencies** â†’ "no test implementation" crash
- **TestStore in setUp()** â†’ Use lazy var instead

### âœ… ESSENTIAL PATTERNS:
- **Use `@MainActor`** for TCA feature tests
- **Always use keypaths** for `receive()`: `await sut.receive(\.action)`
- **Mock all dependencies** in `withDependencies` block
- **Handle ALL actions** or use `skipInFlightEffects()` when effects exist
- **Use lazy vars** for TestStore initialization
- **Test complete user journeys** with descriptive names

### ğŸ”§ SYNTAX REMINDERS:
```swift
// âœ… Correct TCA syntax
await sut.send(.action) { $0.property = value }
await sut.receive(\.action) { $0.property = value }
await sut.receive(\.action, expectedValue)

// âœ… TestStore setup
lazy var sut = TestStoreOf<Feature>(initialState: Feature.State()) {
    Feature(useCase: useCase)
}
```

## ğŸ’¬ Code Comments Best Practices

### Rule: Comments Should Explain WHY, Not WHAT
**Problem**: Obvious comments create noise and become outdated quickly.
**Solution**: Write self-documenting code and only comment business logic or architectural decisions.

#### âŒ BAD COMMENTS: State the Obvious
```swift
// âŒ WRONG - Comment duplicates what code shows
// Set loading state to true
state.isLoading = true

// âŒ WRONG - Comment explains syntax, not intent
// Send action to update routes
await send(.updateRoutes(routes))

// âŒ WRONG - Comment restates variable name
// Hide activity indicator
state.showActivityIndicator = false
```

#### âœ… GOOD COMMENTS: Hidden/Non-obvious Logic Only
```swift
// âœ… GOOD - Hidden timing dependency that's not obvious from code
func testComplexPublisherChainWithHiddenDependency() async {
    // This 50ms delay is critical - without it, the publisher chain creates a race condition
    // where storeChangeLoadingState(false) arrives before updateRoutes, causing test flakiness
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
        useCase.stubbedStoreChangeLoadingState.send(false)
    }

    await sut.send(.initialize) { $0.isLoaded = true }
    // ... rest of test
}

// âœ… GOOD - Non-obvious mock behavior that affects test outcome
func setupMockWithCounterIntuitiveLogic() {
    // Mock returns success but triggers failure callback due to internal retry logic
    // This simulates real network behavior where 200 response can still indicate failure
    mockNetworkService.stubResponse = .success(data)
    mockNetworkService.shouldTriggerFailureCallback = true
}

// âœ… GOOD - Complex algorithm that's not obvious from variable names
private func generateTestDataWithSpecificPattern() -> [Route] {
    // Generate routes where every 3rd route has pending uploads to test batch processing edge case
    // This specific pattern triggers a bug in the grouping algorithm that only occurs with this ratio
    return (0..<10).map { index in
        let hasPendingUpload = (index + 1) % 3 == 0
        return Route.sample(uploadStatus: hasPendingUpload ? .pending : .success)
    }
}
```

#### âœ… WHEN TO COMMENT IN TESTS:
- **Hidden timing dependencies**: Critical delays that prevent race conditions
- **Counter-intuitive mock behavior**: Mocks that behave unexpectedly for good reasons
- **Specific test data patterns**: Data that triggers edge cases or specific bugs
- **Non-obvious test setup**: Complex arrangements that aren't clear from code alone

#### âŒ WHEN NOT TO COMMENT IN TESTS:
- **Test flow description**: `// Send initialize action` - test name should explain this
- **Assertion explanations**: `// Verify spinner is visible` - assertion should be clear
- **Standard TCA test patterns**: `await sut.send()`, `await sut.receive()`
- **Mock setup**: `mockUseCase.stubbedResponse = data` - obvious from code
- **State expectations**: `$0.isLoading = true` - clear from context

### Self-Documenting Code Principles
```swift
// âœ… GOOD - Descriptive names eliminate need for comments
func testStoreChangeLoadingStateSpinnerControl() async {
    // No comment needed - test name explains intent
}

// âœ… GOOD - Clear variable names
let isStoreChangeInProgress = true
// vs
let flag = true // âŒ Needs comment to explain

// âœ… GOOD - Descriptive action names
case .storeChangeLoadingStateChanged(Bool)
// vs
case .update(Bool) // âŒ Needs comment to explain
```

**Remember: TCA testing verifies complete user workflows through state transitions. Always run tests first to see actual behavior, then match expectations.**