---
description: GRDB database patterns, network layer with HttpService, caching strategies, and offline-first data management
---
# Data Layer Essentials - Digital Shelf iOS

## üîë Keywords & Usage

**Use this rule when you write:**
- "database", "save data", "load data", "query"
- "API", "network", "fetch", "upload", "download"
- "repository", "data source", "data access"
- "cache", "caching", "store locally"
- "offline", "sync", "background sync"
- "migration", "add column", "schema change"

**Example prompts:**
- "Create repository for routes"
- "Fetch data from API"
- "Save routes to database"
- "Add caching for images"
- "Design offline-first data flow"
- "Add new field to database"

---

## üóÑÔ∏è GRDB Database Patterns

### How to Create GRDB Repository

**Steps:**
1. **Add `@Dependency(\.database)`** - Inject database
2. **Create publisher** - Use `ValueObservation.tracking { }`
3. **Add fetch methods** - Use `database.reader.read { }`
4. **Add save methods** - Use `database.writer.write { }`
5. **Add `makeWithDeps`** - Wrap in `#if DEBUG` for tests

### Repository with ValueObservation

```swift
final class RouteDataRepository {
    @Dependency(\.database) var database

    // ‚úÖ Reactive publisher for real-time updates
    var allRoutesPublisher: AnyPublisher<[Route], Error> {
        ValueObservation
            .tracking { db in
                try Route.fetchAll(db)
            }
            .publisher(in: database.writer, scheduling: .immediate)
            .eraseToAnyPublisher()
    }

    // ‚úÖ One-time fetch
    func fetchRoute(id: Route.ID) throws -> Route? {
        try database.reader.read { db in
            try Route.fetchOne(db, key: id)
        }
    }

    // ‚úÖ Write operations
    func save(_ route: Route) throws {
        try database.writer.write { db in
            try route.save(db)
        }
    }

    // ‚úÖ Batch operations
    func saveRoutes(_ routes: [Route]) throws {
        try database.writer.write { db in
            for route in routes {
                try route.save(db)
            }
        }
    }
}
```

### ValueObservation Patterns

**With Filtering:**
```swift
func routesForStore(_ storeId: Store.ID) -> AnyPublisher<[Route], Error> {
    ValueObservation
        .tracking { db in
            try Route
                .filter(Column("storeId") == storeId)
                .order(Column("createdAt").desc)
                .fetchAll(db)
        }
        .publisher(in: database.writer)
        .eraseToAnyPublisher()
}
```

**With Joins:**
```swift
var routesWithAislesPublisher: AnyPublisher<[RouteWithAisles], Error> {
    ValueObservation
        .tracking { db in
            let routes = try Route.fetchAll(db)
            return try routes.map { route in
                let aisles = try route.aisles.fetchAll(db)
                return RouteWithAisles(route: route, aisles: aisles)
            }
        }
        .publisher(in: database.writer)
        .eraseToAnyPublisher()
}
```

### Database Migrations

```swift
extension AppDatabase {
    static func migrator() -> DatabaseMigrator {
        var migrator = DatabaseMigrator()

        // v1.0 - Initial schema
        migrator.registerMigration("v1.0") { db in
            try db.create(table: "route") { t in
                t.column("id", .text).primaryKey()
                t.column("name", .text).notNull()
                t.column("storeId", .text).notNull()
                t.column("createdAt", .datetime).notNull()
            }
        }

        // v1.1 - Add column
        migrator.registerMigration("v1.1") { db in
            try db.alter(table: "route") { t in
                t.add(column: "isCompleted", .boolean)
                    .notNull()
                    .defaults(to: false)
            }
        }

        // v1.2 - Create index
        migrator.registerMigration("v1.2") { db in
            try db.create(
                index: "route_on_storeId",
                on: "route",
                columns: ["storeId"]
            )
        }

        return migrator
    }
}
```

**Migration Best Practices:**
- Use sequential version numbers
- Never modify existing migrations
- Test on production-like data
- Add indexes for queried columns

---

## üåê Network Layer Patterns

### HttpEndpoint Protocol (Project-Specific)

```swift
struct FetchRoutesEndpoint: HttpEndpoint {
    typealias Response = [RouteDTO]

    let storeId: Store.ID

    var method: HttpMethod { .get }
    var path: String { "/api/v1/stores/\(storeId)/routes" }
    var headers: [String: String] { ["Accept": "application/json"] }
    var queryParameters: [String: String]? {
        ["include": "aisles,modules"]
    }
}

struct UploadModuleEndpoint: HttpEndpoint {
    typealias Response = UploadResponse

    let routeId: Route.ID
    let moduleData: Data

    var method: HttpMethod { .post }
    var path: String { "/api/v1/routes/\(routeId)/modules" }
    var body: Data? { moduleData }
    var headers: [String: String] {
        ["Content-Type": "application/json"]
    }
}
```

### Network Repository Pattern

```swift
final class RouteNetworkRepository {
    @Dependency(\.httpService) var httpService
    @Dependency(\.apiTokenProvider) var apiTokenProvider

    func fetchRoutes(storeId: Store.ID) async throws -> [Route] {
        let endpoint = FetchRoutesEndpoint(storeId: storeId)
        let dtos = try await httpService.request(endpoint)
        return dtos.map { $0.toDomain() }
    }

    // ‚úÖ Parallel requests with TaskGroup (CRITICAL: capture dependencies!)
    func fetchMultipleRoutes(routeIds: [Route.ID]) async throws -> [Route] {
        let httpService = self.httpService  // Capture before TaskGroup!

        return try await withThrowingTaskGroup(of: Route.self) { group in
            for routeId in routeIds {
                group.addTask {
                    let endpoint = FetchRouteEndpoint(routeId: routeId)
                    let dto = try await httpService.request(endpoint)
                    return dto.toDomain()
                }
            }

            var routes: [Route] = []
            for try await route in group {
                routes.append(route)
            }
            return routes
        }
    }
}
```

---

## üíæ Caching Patterns

### Simple In-Memory Cache with Expiration

```swift
final class CacheRepository<Key: Hashable, Value> {
    private var cache: [Key: CachedValue] = [:]
    private let expirationInterval: TimeInterval

    struct CachedValue {
        let value: Value
        let timestamp: Date
    }

    init(expirationInterval: TimeInterval = 300) {  // 5 min default
        self.expirationInterval = expirationInterval
    }

    func get(_ key: Key) -> Value? {
        guard let cached = cache[key] else { return nil }

        // Check expiration
        if Date().timeIntervalSince(cached.timestamp) > expirationInterval {
            cache.removeValue(forKey: key)
            return nil
        }

        return cached.value
    }

    func set(_ value: Value, forKey key: Key) {
        cache[key] = CachedValue(value: value, timestamp: Date())
    }

    func clear() {
        cache.removeAll()
    }
}
```

### Reactive Cache with Publisher

```swift
final class ReactiveCache<Value> {
    private let subject = CurrentValueSubject<Value?, Never>(nil)
    private var cachedValue: (value: Value, timestamp: Date)?
    private let expirationInterval: TimeInterval

    var publisher: AnyPublisher<Value?, Never> {
        subject.eraseToAnyPublisher()
    }

    func set(_ value: Value) {
        cachedValue = (value, Date())
        subject.send(value)
    }

    func clear() {
        cachedValue = nil
        subject.send(nil)
    }
}
```

---

## üîÑ Offline-First Pattern (Critical for App)

### Strategy: Local First ‚Üí Network Background ‚Üí Sync

```swift
final class OfflineFirstRepository {
    @Dependency(\.database) var database
    @Dependency(\.networkRepository) var networkRepository

    // ‚úÖ Load local immediately, fetch network in background
    func getRoutes(storeId: Store.ID) -> AnyPublisher<[Route], Error> {
        // 1. Immediate local data
        let localPublisher = ValueObservation
            .tracking { db in
                try Route
                    .filter(Column("storeId") == storeId)
                    .fetchAll(db)
            }
            .publisher(in: database.writer, scheduling: .immediate)

        // 2. Background network fetch + sync
        Task {
            do {
                let routes = try await networkRepository.fetchRoutes(
                    storeId: storeId
                )
                try saveToDatabase(routes)
            } catch {
                Log.error("Network sync failed: \(error)")
                // Local data remains valid
            }
        }

        return localPublisher.eraseToAnyPublisher()
    }

    private func saveToDatabase(_ routes: [Route]) throws {
        try database.writer.write { db in
            for route in routes {
                try route.save(db)
            }
        }
    }
}
```

### Sync Status Tracking

```swift
enum SyncStatus: Equatable {
    case synced
    case syncing
    case pendingSync
    case failed(String)
}

actor SyncManager {
    private let syncStatusSubject = CurrentValueSubject<SyncStatus, Never>(.synced)

    var syncStatusPublisher: AnyPublisher<SyncStatus, Never> {
        syncStatusSubject.eraseToAnyPublisher()
    }

    func syncData() async {
        syncStatusSubject.send(.syncing)

        do {
            try await performSync()
            syncStatusSubject.send(.synced)
        } catch {
            syncStatusSubject.send(.failed(error.localizedDescription))
        }
    }
}
```

---

## üìã Best Practices Checklist

### Database Operations
- [ ] Use `ValueObservation` for reactive data
- [ ] Write in `database.writer.write { }`
- [ ] Read in `database.reader.read { }`
- [ ] Batch multiple operations
- [ ] Add indexes for queried columns
- [ ] Test migrations on production-like data

### Network Operations
- [ ] Use `HttpEndpoint` protocol for type safety
- [ ] Implement retry logic for retryable errors
- [ ] **CRITICAL**: Capture `@Dependency` before TaskGroup
- [ ] Handle timeout errors gracefully
- [ ] Map DTOs to domain models in repository
- [ ] Provide user-friendly error messages

### Caching
- [ ] Set appropriate expiration intervals
- [ ] Clear cache on logout/store change
- [ ] Periodically clear expired entries
- [ ] Use reactive cache for UI updates

### Offline-First
- [ ] Load local data immediately
- [ ] Fetch network data in background
- [ ] Sync database with network response
- [ ] Track sync status for user feedback
- [ ] Handle conflicts between local/remote data
- [ ] Queue operations when offline

---

## üéØ Quick Reference

**Database**: GRDB + ValueObservation for reactive data
**Network**: HttpEndpoint + retry logic + error handling
**Caching**: Time-based expiration + reactive publishers
**Offline-First**: Local first, network background, sync database
**Critical**: Capture `@Dependency` before TaskGroup in network operations!

**Remember: Local data provides immediate UX, network sync ensures freshness.**
