---
description: Logging patterns, debugging view flows, data flow tracing, performance measurement, and troubleshooting strategies
---
# Debugging & Logging - Digital Shelf iOS

## üîë Keywords & Usage

**Use this rule when you write:**
- "logging", "log", "debug", "trace"
- "troubleshoot", "why not working", "investigate"
- "publisher not emitting", "data not updating"
- "action flow", "state changes", "timing issue"
- "performance", "slow", "measure"
- "memory leak", "race condition", "crash"

**Example prompts:**
- "Add logging to this feature"
- "Debug why data not updating"
- "Trace publisher emissions"
- "Find memory leak in this code"
- "Why is this action not firing?"
- "Measure performance of this operation"

---

## üìù Logging Levels & When to Use

### How to Choose Log Level

**Decision Tree:**
1. **Is it normal operation?** ‚Üí `Log.debug` or `Log.info`
   - Details only dev needs? ‚Üí `Log.debug`
   - Important user/system events? ‚Üí `Log.info`
2. **Is it unexpected?** ‚Üí `Log.warning` or `Log.error`
   - App continues working? ‚Üí `Log.warning`
   - Operation failed? ‚Üí `Log.error`
3. **Is it catastrophic?** ‚Üí `Log.critical`
   - Data corruption or loss? ‚Üí `Log.critical`

### Log Level Guidelines

```swift
// ‚úÖ Log.debug - Development details
Log.debug("Cache hit for key: \(key)")
Log.debug("Publisher emitted: \(value)")

// ‚úÖ Log.info - Important events & flow
Log.info("User logged in: \(userId)")
Log.info("Route sync started for store: \(storeId)")
Log.info("Navigation: Home ‚Üí RouteDetails")

// ‚úÖ Log.warning - Unexpected but recoverable
Log.warning("API returned empty data, using cached version")
Log.warning("Image failed to load, showing placeholder")
Log.warning("Store changed during operation, canceling")

// ‚úÖ Log.error - Errors requiring attention
Log.error("Failed to save route: \(error)")
Log.error("Network request failed: \(error.localizedDescription)")
Log.error("Database migration failed: \(error)")

// ‚úÖ Log.critical - Fatal errors, data loss
Log.critical("Database corruption detected")
Log.critical("Failed to initialize core dependency: \(error)")
```

### Structured Logging

```swift
// ‚úÖ GOOD - Structured with context
Log.info("Route sync completed", metadata: [
    "storeId": storeId,
    "routeCount": routes.count,
    "duration": duration
])

// ‚úÖ GOOD - Action-oriented
Log.error("Failed to upload module", metadata: [
    "routeId": routeId,
    "moduleId": moduleId,
    "error": error.localizedDescription,
    "attemptNumber": attempt
])

// ‚ùå BAD - Unstructured
Log.info("Sync done got \(routes.count) routes")
```

---

## üîç TCA Flow Debugging

### How to Debug TCA Flow

**Step-by-step:**
1. **Add action logging** - Log every action in reducer
2. **Add state logging** - Log state changes (use DebugReducer)
3. **Add effect logging** - Log effect start/success/failure
4. **Run test** - Use TestStore with exhaustivity
5. **Analyze logs** - Find where flow breaks

### Reducer Action Logging

```swift
@Reducer
struct RouteListFeature {
    var body: some ReducerOf<Self> {
        Reduce { state, action in
            // ‚úÖ Log every action for debugging
            #if DEBUG
            Log.debug("üì• Action: \(action)")
            #endif

            switch action {
            case .onAppear:
                Log.info("RouteList appeared")
                state.isLoading = true
                return .merge(
                    .publisher {
                        useCase.routesPublisher.map(Action.routesUpdated)
                    }
                    .cancellable(id: CancelID.routes)
                )

            case .routesUpdated(let routes):
                Log.info("Routes updated", metadata: ["count": routes.count])
                state.routes = routes
                state.isLoading = false
                return .none
            }
        }
    }
}
```

### State Change Tracking

```swift
@Reducer
struct DebugReducer<Base: Reducer>: Reducer {
    let base: Base

    var body: some ReducerOf<Base> {
        Reduce { state, action in
            #if DEBUG
            let oldState = state
            #endif

            let effects = base.reduce(into: &state, action: action)

            #if DEBUG
            if oldState != state {
                Log.debug("üîÑ State changed", metadata: [
                    "action": "\(action)",
                    "changes": stateDiff(old: oldState, new: state)
                ])
            }
            #endif

            return effects
        }
    }
}

// Usage
var body: some ReducerOf<Self> {
    DebugReducer(base: MyFeature())
}
```

### Effect Lifecycle Tracking

```swift
case .loadData:
    state.isLoading = true

    return .run { send in
        Log.debug("‚è≥ Effect started: loadData")

        do {
            let data = try await useCase.fetchData()
            Log.debug("‚úÖ Effect succeeded: loadData")
            await send(.dataLoaded(data))
        } catch {
            Log.error("‚ùå Effect failed: loadData", metadata: ["error": "\(error)"])
            await send(.loadingFailed(error.localizedDescription))
        }
    }
```

---

## üì° Publisher Debugging

### How to Debug Publishers

**Step-by-step:**
1. **Add handleEvents** - Log subscription/output/completion/cancel
2. **Add metadata** - Include timestamp, thread, value
3. **Run and observe** - Watch log output
4. **Identify issue** - Missing emissions? Early cancel? Wrong timing?
5. **Fix and verify** - Re-run with logging still enabled

**Quick Add:**
```swift
publisher
    .handleEvents(
        receiveOutput: { Log.debug("Emitted: \($0)") },
        receiveCancel: { Log.debug("Cancelled") }
    )
```

### Comprehensive Publisher Logging

```swift
var routesPublisher: AnyPublisher<[Route], Error> {
    ValueObservation
        .tracking { db in
            try Route.fetchAll(db)
        }
        .publisher(in: database.writer)
        .handleEvents(
            receiveSubscription: { _ in
                Log.debug("üì° Publisher subscribed: routesPublisher")
            },
            receiveOutput: { routes in
                Log.debug("üì§ Publisher emitted", metadata: [
                    "publisher": "routesPublisher",
                    "count": routes.count
                ])
            },
            receiveCompletion: { completion in
                switch completion {
                case .finished:
                    Log.debug("‚úÖ Publisher completed: routesPublisher")
                case .failure(let error):
                    Log.error("‚ùå Publisher failed: routesPublisher", metadata: [
                        "error": "\(error)"
                    ])
                }
            },
            receiveCancel: {
                Log.debug("üö´ Publisher cancelled: routesPublisher")
            }
        )
        .eraseToAnyPublisher()
}
```

### Publisher Chain Debugging

```swift
var filteredRoutesPublisher: AnyPublisher<[Route], Never> {
    routesPublisher
        .handleEvents(receiveOutput: { routes in
            Log.debug("üîó Step 1: Raw routes", metadata: ["count": routes.count])
        })
        .map { routes in
            routes.filter { $0.isActive }
        }
        .handleEvents(receiveOutput: { routes in
            Log.debug("üîó Step 2: Filtered routes", metadata: ["count": routes.count])
        })
        .catch { error -> AnyPublisher<[Route], Never> in
            Log.error("Publisher chain error", metadata: ["error": "\(error)"])
            return Just([]).eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}
```

### Combine Operators Debug Extensions

```swift
extension Publisher {
    func debugLog(
        _ prefix: String,
        logLevel: LogLevel = .debug
    ) -> Publishers.HandleEvents<Self> {
        handleEvents(
            receiveSubscription: { _ in
                Log.log(level: logLevel, "[\(prefix)] Subscribed")
            },
            receiveOutput: { output in
                Log.log(level: logLevel, "[\(prefix)] Output: \(output)")
            },
            receiveCompletion: { completion in
                Log.log(level: logLevel, "[\(prefix)] Completed: \(completion)")
            },
            receiveCancel: {
                Log.log(level: logLevel, "[\(prefix)] Cancelled")
            }
        )
    }
}

// Usage
routesPublisher
    .debugLog("Routes")
    .map { $0.filter(\.isActive) }
    .debugLog("ActiveRoutes")
```

---

## üêõ Common Debugging Scenarios

### Debugging Race Conditions

```swift
// Add timing logs to identify race conditions
case .storeChanged(let newStoreId):
    let timestamp = Date().timeIntervalSince1970
    Log.info("üè™ Store changed", metadata: [
        "timestamp": timestamp,
        "newStoreId": newStoreId
    ])

    return .run { send in
        Log.debug("‚è±Ô∏è Clearing routes", metadata: ["timestamp": timestamp])
        await send(.clearRoutes)

        try await Task.sleep(for: .milliseconds(100))

        Log.debug("‚è±Ô∏è Loading new routes", metadata: ["timestamp": timestamp])
        await send(.loadRoutes(storeId: newStoreId))
    }
```

### Debugging Publisher Timing

```swift
var storeChangePublisher: AnyPublisher<Store.ID?, Never> {
    storeRepository.$activeStoreId
        .handleEvents(receiveOutput: { storeId in
            let timestamp = Date().timeIntervalSince1970
            Log.debug("‚è∞ Store ID changed", metadata: [
                "storeId": storeId ?? "nil",
                "timestamp": timestamp,
                "thread": Thread.current.description
            ])
        })
        .eraseToAnyPublisher()
}
```

### Debugging Memory Leaks

```swift
final class RouteListUseCase {
    init() {
        Log.debug("üÜï RouteListUseCase.init()")
    }

    deinit {
        Log.debug("‚ôªÔ∏è RouteListUseCase.deinit()")
    }
}

// If deinit never called ‚Üí memory leak
```

### Debugging Navigation Issues

```swift
// In NavigationStore
func push<D: Hashable>(_ destination: D) {
    Log.info("üß≠ Navigation push", metadata: [
        "destination": "\(type(of: destination))",
        "value": "\(destination)",
        "currentPathCount": path.count
    ])
    path.append(destination)
}

func pop() {
    Log.info("üîô Navigation pop", metadata: [
        "remainingPathCount": path.count - 1
    ])
    path.removeLast()
}
```

---

## üîß Debugging Tools & Techniques

### TestStore Exhaustive Testing

```swift
func testRouteLoading() async {
    // Enable exhaustive testing for detailed feedback
    sut.exhaustivity = .on

    await sut.send(.loadRoutes) {
        $0.isLoading = true
    }

    // TestStore will fail if any action is unhandled
    await sut.receive(\.routesLoaded) {
        $0.routes = [.sample()]
        $0.isLoading = false
    }
}
```

### Performance Measurement

```swift
func measureOperation<T>(
    _ name: String,
    operation: () throws -> T
) rethrows -> T {
    let start = Date()
    defer {
        let duration = Date().timeIntervalSince(start)
        Log.info("‚è±Ô∏è Performance", metadata: [
            "operation": name,
            "duration": String(format: "%.2fms", duration * 1000)
        ])
    }
    return try operation()
}

// Usage
let routes = measureOperation("Fetch routes") {
    try dataRepository.fetchAllRoutes()
}
```

### Async Operation Tracking

```swift
actor OperationTracker {
    private var activeOperations: [String: Date] = [:]

    func start(_ operation: String) {
        activeOperations[operation] = Date()
        Log.debug("‚ñ∂Ô∏è Operation started", metadata: ["operation": operation])
    }

    func complete(_ operation: String) {
        if let startTime = activeOperations.removeValue(forKey: operation) {
            let duration = Date().timeIntervalSince(startTime)
            Log.debug("‚úÖ Operation completed", metadata: [
                "operation": operation,
                "duration": String(format: "%.2fs", duration)
            ])
        }
    }

    func logActiveOperations() {
        Log.debug("üìä Active operations", metadata: [
            "count": activeOperations.count,
            "operations": activeOperations.keys.joined(separator: ", ")
        ])
    }
}
```

---

## üìã Debugging Checklist

### Before Debugging
- [ ] Read error message carefully
- [ ] Check logs for context
- [ ] Identify which layer has the issue (Presentation, Business, Data)
- [ ] Reproduce the issue reliably

### TCA Issues
- [ ] Log all actions in reducer
- [ ] Check state changes with debug reducer
- [ ] Verify effect lifecycle (start, success, failure)
- [ ] Check for unhandled actions in TestStore
- [ ] Verify CancelID uniqueness

### Publisher Issues
- [ ] Add `.handleEvents()` to trace emissions
- [ ] Check subscription timing (too early/late?)
- [ ] Verify cancellation behavior
- [ ] Check for retain cycles with `weakSink`
- [ ] Trace complete publisher chain

### Performance Issues
- [ ] Measure operation duration
- [ ] Check for unnecessary publisher emissions
- [ ] Profile database queries
- [ ] Check for main thread blocking
- [ ] Verify proper cancellation

### Memory Issues
- [ ] Add init/deinit logging
- [ ] Check for strong reference cycles
- [ ] Verify effect cancellation
- [ ] Use Memory Graph Debugger
- [ ] Check publisher retain cycles

---

## üéØ Quick Reference

**Log Levels**: debug (dev details) ‚Üí info (events) ‚Üí warning (recoverable) ‚Üí error (attention) ‚Üí critical (fatal)

**TCA Debugging**: Log actions, track state changes, trace effect lifecycle

**Publishers**: Use `.handleEvents()` for comprehensive tracing

**Performance**: Measure with timestamps, track operation duration

**Memory**: Log init/deinit, check for missing deinit calls

**Tools**: TestStore exhaustivity, Memory Graph, Instruments

**Remember: Good logging is investment in future debugging speed.**
