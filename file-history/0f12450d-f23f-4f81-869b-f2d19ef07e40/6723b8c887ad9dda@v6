// Copyright Â© 2024 Scandit. All rights reserved.

import ComposableArchitecture
import Perception

@Reducer
struct MappingFlowStore {
    @ObservableState
    struct State: Equatable {
        var aisleList: AisleListViewFeature.State
        var moduleList: MappingModuleListFeature.State?
        var modulePreview: MappingModeModulePreviewFeature.State?
        var capture: MappingCaptureFeature.State?
        var toastMessage: ToastMessage?

        var cameraViewModel: UpdateFlowCameraViewModel?

        init(store: Store) {
            aisleList = AisleListViewFeature.State(
                networkStatus: .init(config: .aisleList),
                storeName: store.name,
                storeId: store.id,
                sessionTypes: [],
                showAislesWithoutModules: true,
                allowAisleCreation: true
            )
            moduleList = nil
            modulePreview = nil
            capture = nil
        }
    }

    enum Action {
        case aisleList(AisleListViewFeature.Action)
        case moduleList(MappingModuleListFeature.Action)
        case modulePreview(MappingModeModulePreviewFeature.Action)
        case capture(MappingCaptureFeature.Action)
        case dismissToast
    }

    @Dependency(\.homeNavigation)
    var navigation
    @Dependency(\.firebaseAnalytics)
    var analytics

    @Dependency(\.aisleService)
    var aisleService

    let useCase: MappingFlowRootUseCase
    let exportOptions: ShelfScanCaptureExportOptions

    @MainActor
    var body: some Reducer<State, Action> {
        Reduce {
            state,
            action in
            switch action {
            case .aisleList(.onAisleSelected(let aisle)):
                analytics.logMappingFlow(event: .aisleSelection)
                state.moduleList = .init(
                    list: .init(
                        aisle: aisle,
                        modules: aisle.modules
                    )
                )
                navigation.push(destination: .aisleModuleListView)
                return .none
                
            case .aisleList(.onAppear):
                analytics.logMappingFlow(event: .aisleListScreen)
                
                return .none
                
            case .aisleList(.addAisle):
                analytics.logMappingFlow(event: .newAisleButton)
                
                return .none
                
            case .moduleList(.list(.onModuleSelected(let aisle, let module))):
                state.modulePreview = .init(
                    module: .existing(details: module),
                    aisle: aisle,
                    isRetaking: true
                )
                navigation.push(destination: .modulePreviewView)
                return .none

            case .moduleList(.list(.onModuleCreated(let aisle, let module))):
                state.modulePreview = .init(
                    module: module,
                    aisle: aisle,
                    isRetaking: false
                )
                navigation.push(destination: .modulePreviewView)
                return .none
                
            case .moduleList(.list(.onInit)):
                if state.cameraViewModel.isNil {
                    state.cameraViewModel = useCase.makeCameraViewModel()
                }
                state.cameraViewModel?.onAppear()
                return .none
                
            case .moduleList(.list(.onDeinit)):
                state.cameraViewModel?.onDisappear()
                state.cameraViewModel = nil
                return .none
                
            case .moduleList(.editAisleName(.presented(.handleSuccessfulUpdate))):
                return .send(.aisleList(.onRefresh))

            case .modulePreview(.onContinueButtonTapped):
                guard let modulePreview = state.modulePreview else { return .none }

                updateCaptureState(
                    state: &state,
                    module: modulePreview.module,
                    isRetaking: modulePreview.isRetaking
                )
                navigation.push(destination: .selectedModuleView)
                return .none

            case .modulePreview(.viewDisappeared):
                state.modulePreview = nil
                return .none

            case .capture(.viewDisappeared):
                state.capture = nil
                return .none

            case .aisleList(.aisleCreationError(let err)):
                state.toastMessage = .error(
                    err.aisleErrorDescription ?? L10n.MappingFlow.List.aisleCreationError
                )
                
                return .none
                
            case .dismissToast:
                state.toastMessage = nil
                return .none
                
            case .aisleList,
                    .moduleList,
                    .modulePreview,
                    .capture:
                return .none
            }
        }
        .ifLet(\.moduleList, action: \.moduleList) {
            MappingModuleListFeature()
        }
        .ifLet(\.modulePreview, action: \.modulePreview) {
            MappingModeModulePreviewFeature()
        }
        .ifLet(\.capture, action: \.capture) {
            MappingCaptureFeature(exportOptions: exportOptions)
        }
        Scope(state: \.aisleList, action: \.aisleList) {
            AisleListViewFeature()
        }
    }

    @MainActor
    private func updateCaptureState(
        state: inout MappingFlowStore.State,
        module: ShelfScanModule,
        isRetaking: Bool
    ) {
        guard let moduleList = state.moduleList else { return }

        if var captureState = state.capture {
            updateCaptureStateModule(
                state: &captureState,
                module: module,
                moduleList: moduleList.list
            )
            state.capture = captureState
            return
        }

        initializeCaptureState(
            state: &state,
            module: module,
            moduleList: moduleList.list,
            isRetaking: isRetaking
        )
    }

    @MainActor
    private func updateCaptureStateModule(
        state: inout MappingCaptureFeature.State,
        module: ShelfScanModule,
        moduleList: AisleModuleListFeature.State
    ) {
        state.module = module
        state.loadingSpinner = nil
        // Update allModules and currentIndex when module changes
        var allModules = moduleList.modules.map { ShelfScanModule.existing(details: $0) }

        // If the module is not in the list (new module), add it
        if let existingIndex = allModules.firstIndex(where: { $0.isEqualTo(module) }) {
            state.currentModuleIndex = existingIndex
        } else {
            // New module - add it to the list
            allModules.append(module)
            state.currentModuleIndex = allModules.count - 1
        }

        state.allModules = allModules
    }

    @MainActor
    private func initializeCaptureState(
        state: inout MappingFlowStore.State,
        module: ShelfScanModule,
        moduleList: AisleModuleListFeature.State,
        isRetaking: Bool
    ) {
        guard let cameraViewModel = state.cameraViewModel else {
            assertionFailure("Camera view model must be set before initializing capture state.")
            return
        }

        // For sequential capture, pass all modules and find current index
        var allModules = moduleList.modules.map { ShelfScanModule.existing(details: $0) }

        // If the module is not in the list (new module), add it
        let currentIndex: Int
        if let existingIndex = allModules.firstIndex(where: { $0.isEqualTo(module) }) {
            currentIndex = existingIndex
        } else {
            // New module - add it to the list
            allModules.append(module)
            currentIndex = allModules.count - 1
        }

        state.capture = .init(
            module: module,
            allModules: allModules,
            currentModuleIndex: currentIndex,
            cameraViewModel: cameraViewModel,
            aisle: moduleList.aisle,
            isRetaking: isRetaking
        )
    }
}

private extension Error {
    var aisleErrorDescription: String? {
        guard let response = aisleError?.apiError?.genericError else { return nil }

        return response.nonFieldErrors?.errors.nonFieldErrors.first?.detail
    }
}
