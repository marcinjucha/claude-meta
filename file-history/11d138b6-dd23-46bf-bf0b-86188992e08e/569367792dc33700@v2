# OfflineAvailability Screen

## Overview

Download store data (aisles, modules, preview images) for offline use. Shows download progress, handles cancellation, retries, and outdated data refresh.

## Architecture

**TCA Feature** - Full Composable Architecture implementation.

**Files:**
- **Presentation:** `OfflineAvailabilityFeature.swift`, `OfflineAvailabilityView.swift`, `OfflineDownloadView.swift`

## TCA Feature Structure

### State

```swift
struct State: Equatable {
    let storeId: Int
    let storeName: String

    var previewProgress: ModulePreviewProgress?
    var networkStatus: NetworkStatus = .offline
    var offlineReadinessStatus: OfflineReadinessStatus?
    var toastMessage: ToastMessage?
    var dialogMessage: ConfirmationDialogViewModel?

    // Computed Properties
    var downloadSize: String?
    var progress: Int
    var isDownloadDisabled: Bool
    var downloadState: OfflineDownloadState
}
```

### Download States

```swift
enum OfflineDownloadState {
    case unknown
    case idle
    case inProgress
    case offlineReady
    case outdated
    case outdatedInProgress
}
```

### Key Actions

- `.onAppear` → Subscribe to publishers, refresh status
- `.refreshOfflineStatus` → Check if data is outdated/ready
- `.setOfflineStatus(OfflineReadinessStatus)` → Update readiness state
- `.downloadButtonTapped` → Start download (if online)
- `.inProgressButtonTapped` → Cancel ongoing download
- `.outdatedButtonTapped` → Show refresh confirmation dialog
- `.outdatedInProgressButtonTapped` → Cancel refresh download
- `.downloadData` → Execute download operation
- `.retryDownloadData` → Retry after failure
- `.cancelDownload` → Cancel ongoing operation
- `.downloadError` → Show error toast with retry button
- `.onDownloadStatusUpdated(ModulePreviewProgress?)` → Update progress
- `.subscribeTo(PreviewLoader)` → Subscribe to download progress
- `.subscribeToNetworkStatusUpdates` → Monitor network changes
- `.subscribeToActionPublisher` → Handle internal actions (dialog callbacks)
- `.analytics(event:)` → Log Firebase events

### Reducer Logic

```swift
var body: some ReducerOf<Self> {
    Reduce { state, action in
        switch action {
        case .onAppear:
            return .run { send in
                let operation = modulePreviewRepository.previewLoadingOperation
                await send(.subscribeTo(operation))
                await send(.refreshOfflineStatus)
                await send(.subscribeToNetworkStatusUpdates)
                await send(.subscribeToActionPublisher)
            }

        case .downloadButtonTapped where state.isDownloadDisabled:
            return .send(.showToast(.warn("No connection")))

        case .downloadButtonTapped:
            return .run { send in
                await send(.analytics(event: .downloadModulePreviewsButton))
                await send(.downloadData)
            }

        case .downloadData:
            let storeId = state.storeId
            return .run { send in
                async let routesTask = routeListUseCase.fetchRoutes()
                async let operation = modulePreviewRepository.loadPreviews(forStoreId: storeId)

                let (_, previewOperation) = try await (routesTask, operation)
                await send(.subscribeTo(previewOperation))
            }

        // ... other cases
        }
    }
}
```

## Publishers Pattern

**Download Progress Subscription:**
```swift
case .subscribeTo(let operation):
    return .publisher {
        operation.progress.map(Action.onDownloadStatusUpdated)
    }
    .cancellable(id: CancelID.download)
```

**Network Status Subscription:**
```swift
case .subscribeToNetworkStatusUpdates:
    return .publisher {
        networkStatusMonitor.statusPublisher.map(Action.updateNetworkStatus)
    }
    .cancellable(id: CancelID.networkStatus)
```

**Internal Action Publisher:**
```swift
private let actionPublisher = PassthroughSubject<Action, Never>()

case .subscribeToActionPublisher:
    return .publisher { actionPublisher }
        .cancellable(id: CancelID.retry)
```

## Dependencies

- `@Dependency(\.modulePreviewRepository)` - Download operations
- `@Dependency(\.networkStatusMonitorService)` - Network status monitoring
- `@Dependency(\.firebaseAnalytics)` - Event tracking
- Constructor-injected: `AnyRouteListUseCase` - Fetch routes alongside previews

## ModulePreviewProgress

```swift
enum ModulePreviewProgress: Equatable {
    case idle
    case preparing
    case inProgress(progress: Double, remainingBytes: Double)
    case completed
    case failed(Error)

    var progress: Double? { ... }
    var remainingBytes: Double? { ... }
}
```

## OfflineReadinessStatus

```swift
enum OfflineReadinessStatus {
    case readyToStart(initialProgress: ModulePreviewProgress)
    case offlineReady
    case outdated
}
```

## Key Features

### 1. Network-Aware Downloads
- Disable download button when offline
- Show toast: "No connection" if user tries to download offline

### 2. Progress Tracking
```swift
var progress: Int {
    guard let progress = previewProgress?.progress else { return 0 }
    return (progress * 100.0).integerValue
}

var downloadSize: String? {
    guard let remainingBytes else { return nil }
    return String(format: "%.1f MB", remainingBytes / (1024 * 1024))
}
```

### 3. Outdated Data Handling
- Show refresh dialog with confirmation
- Cancel option for ongoing refresh

```swift
case .outdatedButtonTapped:
    return .send(.showDialog(
        .init(
            title: L10n.Offline.Dialog.title,
            description: L10n.Offline.Dialog.description(storeName),
            primaryButton: .init(
                title: L10n.Offline.Dialog.cta,
                style: .secondary,
                action: { actionPublisher.send(.downloadData) }
            )
        )
    ))
```

### 4. Error Handling with Retry
```swift
case .downloadError:
    return .send(.showToast(
        .error(
            L10n.Offline.Outdated.ErrorToast.text,
            button: .init(
                text: L10n.Offline.Outdated.ErrorToast.retry,
                action: { actionPublisher.send(.retryDownloadData) }
            )
        )
    ))
```

### 5. Parallel Downloads
Downloads routes + module previews concurrently:
```swift
case .downloadData:
    return .run { send in
        async let routesTask = routeListUseCase.fetchRoutes()
        async let operation = modulePreviewRepository.loadPreviews(forStoreId: storeId)

        let (_, previewOperation) = try await (routesTask, operation)
        await send(.subscribeTo(previewOperation))
    }
```

## Analytics Events

```swift
extension FirebaseEvent {
    static let downloadModulePreviewsButton = Self(name: "download_module_previews")
    static let upToDateModulePreviewsButton = Self(name: "up_to_date_module_previews")
    static let refreshModulePreviewsButton = Self(name: "refresh_module_previews")
    static let cancelDownloadModulePreviewsButton = Self(name: "cancel_download_module_previews")
}
```

## Localization

**L10n Keys:**
- `L10n.Offline.Dialog.title/description/cta` - Refresh confirmation dialog
- `L10n.Offline.Outdated.NoConnectionToast.text` - Offline warning
- `L10n.Offline.Outdated.ErrorToast.text/retry` - Error + retry

## Toast & Dialog Integration

**Environment Objects:**
- `@EnvironmentObject var toastEnvironment: ToastEnvironment`
- `@EnvironmentObject var confirmationDialogEnvironment: ConfirmationDialogEnvironment`

**Usage:**
```swift
case .showToast(let message):
    state.toastMessage = message
    return .none

case .showDialog(let message):
    state.dialogMessage = message
    return .none
```

## Testing

**Test Pattern:**
```swift
lazy var sut = TestStore(
    initialState: OfflineAvailabilityFeature.State(storeId: 1, storeName: "Test Store")
) {
    OfflineAvailabilityFeature()
} withDependencies: {
    $0.modulePreviewRepository = mockRepository
    $0.networkStatusMonitorService = mockNetworkMonitor
    $0.firebaseAnalytics = mockAnalytics
}

await sut.send(.onAppear)
await sut.receive(\.subscribeTo)
await sut.receive(\.refreshOfflineStatus)
```

## Common Pitfalls

- ❌ Don't forget to cancel subscriptions on view disappear
- ❌ Don't access `@Dependency` inside TaskGroup (capture first)
- ✅ Always check network status before starting download
- ✅ Use `actionPublisher` for dialog button actions (not direct send)
- ✅ Handle `.completed` progress → refresh offline status
- ✅ Subscribe to preview operation immediately after creation

## Key Patterns

1. **PassthroughSubject for Dialog Actions:** Dialog buttons use `actionPublisher.send()` since they can't directly access TCA store
2. **Multi-Publisher Subscriptions:** Network status + download progress + action publisher
3. **Parallel Async Operations:** Routes fetch + preview download using `async let`
4. **State-Based UI:** `downloadState` computed property drives UI rendering
5. **Network-Aware Logic:** Disable actions when offline, show appropriate toasts
