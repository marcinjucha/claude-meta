# Services - CLAUDE.md

Services to warstwa infrastruktury aplikacji zawierająca niezależne komponenty do obsługi API, bazy danych, analytics, storage, camera i innych systemowych funkcjonalności.

## Key Components

### 1. ShelfAccountStorage (`AccountStorage/ShelfAccountStorage.swift`)

**Responsibility:**
- Zarządzanie sesją użytkownika (login/logout)
- Przechowywanie API token (Keychain)
- Fetch store configuration + offline cache
- Fetch products for sklepu
- Clearowanie danych przy logout

**Key Properties:**
```swift
let isLoggedIn: CurrentValueSubject<Bool, Never>
let products: CurrentValueSubject<[String: Product], Never>
let configInfo: CurrentValueSubject<ConfigInfo?, Never>

var apiToken: String? {  // Keychain storage
    get { secureDataStorage[.apiTokenKey] }
    set {
        secureDataStorage[.apiTokenKey] = newValue
        isLoggedIn.value = newValue != nil
    }
}
```

**Login Flow:**
```swift
func login(email: String, password: String) -> AnyPublisher<Void, Error> {
    // 1. Register device → get API token
    httpService.request(endpoint: RegisterDevice(...))
        .handleEvents { response in
            self.apiToken = response.apiToken
            self.userRepository.setUser(...)
        }
    // 2. Fetch user details
        .flatMap { res in
            httpService.request(endpoint: MeEndpoint(apiToken: res.apiToken))
                .handleEvents { res in
                    self.userRepository.updateUser(id: res.userId, ...)
                }
        }
}
```

**Logout Flow:**
```swift
func logout() async {
    await clear()  // Clear local data first
    guard let apiToken else { return }

    // Notify backend (fire-and-forget)
    try? await httpService.request(endpoint: Logout(apiToken: apiToken))
}

private func clear() async {
    storeRepository.clear()
    appConfigPersistence.clear()
    routeDataRepository.clearRoutes()
    await modulePreviewRepository.removeModulePreviews()
    apiToken = nil
    userRepository.clear()
    dataStorage.clear()
    database.clear()
}
```

**Config Fetch z Offline Fallback:**
```swift
func fetchStoreConfiguration(storeId: Int) -> AnyPublisher<ConfigInfo, Error> {
    httpService.request(endpoint: ConfigEndpoint(...))
        .handleEvents { configInfo in
            // Cache for offline use
            appConfigPersistence.setConfig(forStore: storeId, config: configInfo)
        }
        .catch { error in
            // Fallback do cached config
            if let cachedConfig = appConfigPersistence.getConfig(forStore: storeId) {
                return Just(cachedConfig).setFailureType(to: Error.self)
            }
            return Fail(error: error)
        }
}
```

**Dependencies:**
```
@Dependency(\.secureStorage)        # Keychain
@Dependency(\.keyValueStorage)      # UserDefaults
@Dependency(\.httpService)          # API calls
@Dependency(\.database)             # GRDB
@Dependency(\.appConfigPersistence) # Config cache
@Dependency(\.storeRepository)      # Active store
@Dependency(\.userRepository)       # User data
```

---

### 2. HTTPService (`HTTPService.swift`)

**Responsibility:**
- Generic HTTP client for API calls
- Environment management (production/staging/custom)
- Request/response handling z retry logic
- Error mapping (401, 429, 5xx)
- App compatibility checking

**Core Types:**
```swift
enum HttpEnvironment: Codable {
    case production
    case staging
    case customStaging(String)  // Custom URL
}

enum HttpMethod: String {
    case get, post, patch, put
}

enum HttpHeader {
    case authorization(String)           // Bearer token
    case accept(ContentType)
    case content(ContentType)
    case appVersion(String)
    case appCompatibility(AppCompatibility)  // supported/deprecated/unsupported
    case sdkVersion(String)
    case operatingSystem(String)
    case deviceId(String)
    case cacheControl(CacheControl)
}
```

**Protocol: HttpEndpoint**
```swift
protocol HttpEndpoint {
    var path: String { get }
    var queryItems: [URLQueryItem]? { get }
    var method: HttpMethod { get }
    var headers: [HttpHeader] { get }
}

protocol HasRequestPayload {
    associatedtype RequestPayload: Encodable
    var requestPayload: RequestPayload { get }
}

protocol HasResponsePayload {
    associatedtype ResponsePayload: Decodable
}
```

**Usage Pattern:**
```swift
struct RegisterDevice: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = DeviceInfo
    typealias ResponsePayload = DeviceToken

    let path = "api/v1/device"
    let method: HttpMethod = .post
    let headers: [HttpHeader] = [.content(.json), .accept(.json)]
    let requestPayload: DeviceInfo
}

// Call
httpService.request(endpoint: RegisterDevice(...))
    .sink(receiveCompletion: { ... }, receiveValue: { response in
        print(response.apiToken)
    })
```

**Error Types:**
```swift
enum RequestError: Error {
    case invalid
    case apiTokenMissing
}

struct ResponseError: LocalizedError {
    enum ErrorType {
        case invalidRequest         // 400
        case unauthorized           // 401
        case clientError            // 4xx
        case serverError            // 5xx
        case tooManyRequests        // 429
        case unsupportedAppVersion  // App compatibility check
        case unknown
    }

    let type: ErrorType
    let statusCode: Int
    let error: AnyJson?
    let response: HTTPURLResponse?
}
```

**Retry Logic:**
- Max 3 retries for server errors (5xx)
- Exponential backoff for 429 (Too Many Requests)
- `Retry-After` header support

---

### 3. ShelfDatabase (`Database/ShelfDatabase.swift`)

**Responsibility:**
- GRDB database wrapper
- Reactive publishers for tables
- Migrations
- In-memory database for tests

**Setup:**
```swift
final class ShelfDatabase: AppDatabase {
    static var defaultDatabase: ShelfDatabase {
        isUnitTestRunning ? inMemory() : database
    }

    private static let database: ShelfDatabase = {
        let databaseURL = FileManager.default
            .documentDirectory
            .appendingPathComponent("db.sqlite")
        let queue = try DatabaseQueue(path: databaseURL.path)
        return ShelfDatabase(writer: queue)
    }()

    static func inMemory() -> ShelfDatabase {
        let queue = try DatabaseQueue()  // In-memory
        return ShelfDatabase(writer: queue)
    }
}
```

**Reactive Publishers:**
```swift
var uploadSessions: AnyPublisher<[UploadSessionInfo], Error> {
    initializationSubject
        .filter(\.self)
        .flatMap { _ in
            ValueObservation
                .tracking { database -> [UploadSessionInfo] in
                    try UploadSessionInfo.fetchAll(database)
                }
                .publisher(
                    in: self.writer,
                    scheduling: .async(onQueue: .global(qos: .userInitiated))
                )
        }
        .eraseToAnyPublisher()
}
```

**Record Types:**
- `StoreRecord` - stores
- `RouteRecord` - routes
- `RouteAisleRecord` - route aisles
- `SessionRecord` - capture sessions
- `SessionModuleRecord` - captured modules
- `UploadRequestRecord` - upload requests
- `UploadSessionInfo` - upload status
- `ConfigRecord` - store configurations
- `LogRecord` - app logs

**⚠️ Important:**
- Publishers use `ValueObservation` for reactive updates
- Async scheduling na background queue (`.userInitiated`)
- `initializationSubject` waits for database setup before emitting

---

### 4. DigitalShelfAPI (`DigitalShelfAPI/`)

**Struktura:**
```
DigitalShelfAPI/
├── DigitalShelfAPIService.swift        # Main HTTP service implementation
├── GenericAPIResponseError.swift       # Generic error parsing
└── Endpoints/
    ├── EndpointPath.swift              # Type-safe endpoint paths
    ├── RegisterDevice.swift            # POST /api/v1/device
    ├── MeEndpoint.swift                # GET /api/v1/me
    ├── Logout.swift                    # POST /api/v1/logout
    ├── StoresEndpoint.swift            # GET /api/v1/stores
    ├── ConfigEndpoint.swift            # GET /api/v1/config
    ├── AislesEndpoint.swift            # GET /api/v1/aisles
    ├── CreateAisleEndpoint.swift       # POST /api/v1/aisles
    ├── UpdateAisleEndpoint.swift       # PATCH /api/v1/aisles/:id
    ├── ModulesEndpoint.swift           # GET /api/v1/modules
    ├── CreateModuleEndpoint.swift      # POST /api/v1/modules
    ├── UploadModuleImageEndpoint.swift # PUT /api/v1/module/:id/image
    ├── RouteEndpoint.swift             # GET /api/v1/routes
    ├── RouteDetailsEndpoint.swift      # GET /api/v1/routes/:id
    ├── Products.swift                  # GET /api/v1/products
    ├── ProductsStores.swift            # GET /api/v1/product-stores
    └── ... (20+ endpoints total)
```

**EndpointPath Pattern:**
```swift
struct EndpointPath {
    let path: String
    private let isEndpoint: (String, URL) -> Bool  // URL matching

    func isEndpoint(forURL url: URL?) -> Bool {
        guard let url else { return false }
        return isEndpoint(path, url)
    }
}

extension EndpointPath {
    static let registerDevice = EndpointPath(path: "api/v1/device")
    static let aisles = EndpointPath(path: "api/v1/aisles")
    static let modules = EndpointPath(path: "api/v1/modules")
    // ...
}
```

**Endpoint Example:**
```swift
struct CreateAisleEndpoint: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = CreateAisleRequest
    typealias ResponsePayload = AisleResponse

    struct CreateAisleRequest: Encodable {
        let name: String
        let storeId: Int
    }

    struct AisleResponse: Decodable {
        let id: Int
        let name: String
        let createdAt: Date
    }

    let path = "api/v1/aisles"
    let method: HttpMethod = .post
    let headers: [HttpHeader]
    let queryItems: [URLQueryItem]? = nil
    let requestPayload: CreateAisleRequest

    init(apiToken: String, name: String, storeId: Int) {
        self.headers = [
            .authorization(apiToken),
            .content(.json),
            .accept(.json)
        ]
        self.requestPayload = CreateAisleRequest(name: name, storeId: storeId)
    }
}
```

**GenericAPIResponseError:**
```swift
struct GenericAPIResponseError: Decodable {
    let detail: String
    let title: String
    let status: Int

    var errorMessage: String { "\(title): \(detail)" }
}
```

**⚠️ Important:**
- Wszystkie endpointy są type-safe structs
- Request/Response payloads as nested types
- API token passed in constructor (nie globalny state)
- Error handling via `ResponseError` + `GenericAPIResponseError`

---

---

## 5. Upload System (`Upload/`)

**Responsibility:**
- Background upload captured images/sessions do serwera
- Queue management z concurrency control
- Retry logic z exponential backoff
- Progress tracking
- Metadata upload

### UploadSessionHandler (Singleton)

**Key Properties:**
```swift
class UploadSessionHandler {
    static let shared = UploadSessionHandler()
    static let backgroundIdentifier = "com.scandit.shelf.backgroundSession"

    var maxConcurrentUploads: Int = 1  // Configurable
    var activeUploads: AnyPublisher<[UploadRequestRecord], Never>
    private var session: UploadURLSession  // URLSession wrapper
}
```

**Upload Flow:**
```swift
// 1. Subscribe do database + network status
func subscribeToNetworkStatusAndDatabaseUpdates() {
    database.progressableUploadRequests  // DB publisher
        .combineLatest(networkMonitor.statusPublisher, session.runningTasksPublisher)
        .sink { requests, networkStatus, runningTasks in
            // Start uploads when:
            // - Network available
            // - Concurrent limit not exceeded
            // - Requests pending
            self.startUploads(requests, maxConcurrent: self.maxConcurrentUploads)
        }
}

// 2. Start upload task
func startUpload(request: UploadRequestRecord) {
    let task = session.uploadTask(with: request)
    task.resume()
}

// 3. Handle completion
func urlSession(_: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
    if let error {
        markAsFailed(task, error: error)
        scheduleRetry(task)
    } else {
        markAsCompleted(task)
        uploadMetadata(task)  // Upload JSON metadata after image
    }
}
```

**Retry Logic:**
- Exponential backoff: 1s, 2s, 4s, 8s, ...
- Max retry count: configurable
- Network status aware (pause when offline)

**Dependencies:**
```
@Dependency(\.database)                      # Upload tracking
@Dependency(\.uploadDataManager)             # File management
@Dependency(\.networkStatusMonitorService)   # Network awareness
@Dependency(\.uploadAnalytics)               # Upload analytics
@Dependency(\.metadataUploader)              # Metadata upload
```

### Upload Records w Database

**UploadRequestRecord:**
```swift
struct UploadRequestRecord: Codable, PersistableRecord {
    let id: UUID
    let sessionId: SessionRecord.ID
    let resourceIdentifier: ResourceIdentifier  // Uploaded file location
    let status: UploadStatus  // pending, inProgress, completed, failed
    let retryCount: Int
    let error: String?
    let createdAt: Date
    let completedAt: Date?
}

enum UploadStatus: String, Codable {
    case pending, inProgress, completed, failed
}
```

**UploadSessionInfo:**
```swift
struct UploadSessionInfo: Decodable, FetchableRecord {
    let sessionId: SessionRecord.ID
    let totalRequests: Int
    let completedRequests: Int
    let failedRequests: Int
    let inProgressRequests: Int

    var isComplete: Bool { completedRequests == totalRequests }
    var progress: Double { Double(completedRequests) / Double(totalRequests) }
}
```

---

## 6. Persistence Layer (`Persistence/`)

### KeyValueStorage Protocol

**Interface:**
```swift
protocol KeyValueStorage: AnyObject {
    subscript<T: Codable>(_ key: StorageKey) -> T? { get set }

    func clear(forKey key: StorageKey)
    func clear()
}

struct StorageKey: ExpressibleByStringLiteral {
    let value: String
}
```

**Implementations:**
- `UserDefaultsStorage` - UserDefaults backed (non-sensitive data)
- `KeychainStorage` - Keychain backed (sensitive: API token, user ID)

**Usage:**
```swift
// Define keys
extension StorageKey {
    static let apiTokenKey: Self = "apiToken"
    static let activeStoreIdKey: Self = "activeStoreId"
    static let handednessPreference: Self = "handednessPreference"
}

// Usage
@Dependency(\.keyValueStorage)
var storage: KeyValueStorage

storage[.activeStoreIdKey] = 123
let storeId: Int? = storage[.activeStoreIdKey]
```

### StoreRepository

**Responsibility:**
- Active store management
- Persistent storage (UserDefaults)
- Publishers for store changes

```swift
protocol StoreRepository {
    var activeStore: Store? { get set }
    var activeStorePublisher: AnyPublisher<Store?, Never> { get }
    var hasActiveStore: Bool { get }

    func clear()
}

final class ShelfStoreRepository: StoreRepository {
    @Dependency(\.keyValueStorage)
    private var storage

    private let activeStoreSubject = CurrentValueSubject<Store?, Never>(nil)

    var activeStore: Store? {
        get { storage[.activeStoreIdKey].flatMap { /* load from storage */ } }
        set {
            storage[.activeStoreIdKey] = newValue?.id
            activeStoreSubject.send(newValue)
        }
    }

    var activeStorePublisher: AnyPublisher<Store?, Never> {
        activeStoreSubject.eraseToAnyPublisher()
    }
}
```

### UserRepository

**Responsibility:**
- User data management (firstName, lastName, email, ID, orgID)
- Keychain storage for sensitive data
- Thread-safe access

```swift
protocol UserRepository {
    var userId: Int? { get }
    var organizationId: Int? { get }
    var email: String? { get }
    var fullName: String? { get }

    func setUser(firstName: String, lastName: String, email: String)
    func updateUser(id: Int, orgId: Int)
    func clear()
}
```

### AppConfigPersistence

**Responsibility:**
- Store configuration caching (offline support)
- Per-store config storage

```swift
protocol AppConfigPersistence {
    func setConfig(forStore storeId: Int, config: ConfigInfo)
    func getConfig(forStore storeId: Int) -> ConfigInfo?
    func clear()
}
```

**⚠️ Używane w offline fallback:**
```swift
httpService.request(endpoint: ConfigEndpoint(...))
    .handleEvents { config in
        appConfigPersistence.setConfig(forStore: storeId, config: config)
    }
    .catch { error in
        if let cached = appConfigPersistence.getConfig(forStore: storeId) {
            return Just(cached).setFailureType(to: Error.self)
        }
        return Fail(error: error)
    }
```

---

## 7. Database Layer (`Database/`)

### AppDatabase Protocol

**Interface:**
```swift
protocol AppDatabase {
    // Reactive publishers
    var uploadSessions: AnyPublisher<[UploadSessionInfo], Error> { get }
    var uploadRequests: AnyPublisher<[UploadRequestRecord], Error> { get }
    var progressableUploadRequests: AnyPublisher<[UploadRequestRecord], Error> { get }
    var activeUploadRequests: AnyPublisher<[UploadRequestRecord], Error> { get }
    var shelfScanCaptureSessions: AnyPublisher<[ShelfScanSessionInfo], Error> { get }

    // Initialization
    var isInitialized: Bool { get }
    var isInitializedPublisher: AnyPublisher<Bool, Never> { get }

    func setup()
    func clear()

    // CRUD operations
    func transaction(_ block: (DatabaseType) throws -> Void) throws
    func transaction<T>(_ block: (DatabaseType) throws -> T) throws -> T
    func read<T>(_ block: (DatabaseType) throws -> T) throws -> T

    func add(_ record: any PersistableRecord) throws
    func update(_ records: [any PersistableRecord]) throws
    func upsert(_ records: [any PersistableRecord]) throws

    func get<RecordType: Identifiable & PersistableRecord & FetchableRecord>(
        recordId id: RecordType.ID
    ) throws -> RecordType

    func getAll<RecordType: PersistableRecord & FetchableRecord>() throws -> [RecordType]
    func deleteAll<RecordType: PersistableRecord>(_ type: RecordType.Type) throws -> Int

    // Tracking (reactive queries)
    func tracking<Value>(
        _ fetch: @escaping @Sendable (DatabaseType) throws -> Value
    ) -> AnyPublisher<Value, Error>
}
```

### Database Records

**Core Records:**
- `StoreRecord` - Stores
- `ConfigRecord` - Store configurations
- `SessionRecord` - Capture sessions
- `SessionModuleRecord` - Captured modules w session
- `UploadRequestRecord` - Upload requests
- `UploadSessionInfo` - Aggregate upload status (view)
- `RouteRecord` - Routes
- `RouteAisleRecord` - Route aisles
- `LogRecord` - Application logs

**Record Example:**
```swift
struct SessionRecord: Codable, FetchableRecord, PersistableRecord {
    static let databaseTableName = "session"

    let id: Int64?
    let storeId: Int
    let aisleId: Int
    let createdAt: Date
    let updatedAt: Date
    let status: SessionStatus  // draft, inProgress, completed, uploaded

    enum SessionStatus: String, Codable {
        case draft, inProgress, completed, uploaded
    }
}
```

### ShelfDatabase Implementation

**Setup:**
```swift
final class ShelfDatabase: AppDatabase {
    static var defaultDatabase: ShelfDatabase {
        isUnitTestRunning ? inMemory() : database
    }

    private static let database: ShelfDatabase = {
        let databaseURL = FileManager.default
            .documentDirectory
            .appendingPathComponent("db.sqlite")
        let queue = try! DatabaseQueue(path: databaseURL.path)
        return ShelfDatabase(writer: queue)
    }()

    static func inMemory() -> ShelfDatabase {
        let queue = try! DatabaseQueue()  // In-memory
        return ShelfDatabase(writer: queue)
    }

    private let writer: DatabaseQueue
    private let initializationSubject = CurrentValueSubject<Bool, Never>(false)

    func setup() {
        try! writer.write { db in
            try createTables(db)
            try runMigrations(db)
        }
        initializationSubject.send(true)
    }
}
```

**Reactive Publisher Pattern:**
```swift
var uploadSessions: AnyPublisher<[UploadSessionInfo], Error> {
    initializationSubject
        .filter(\.self)  // Wait for initialization
        .flatMap { _ in
            ValueObservation
                .tracking { database -> [UploadSessionInfo] in
                    try UploadSessionInfo.fetchAll(database, UploadSessionInfo.request)
                }
                .publisher(
                    in: self.writer,
                    scheduling: .async(onQueue: .global(qos: .userInitiated))
                )
        }
        .eraseToAnyPublisher()
}
```

**⚠️ Important:**
- `initializationSubject` ensures that publishers nie emitują przed setup()
- Async scheduling na background queue (.userInitiated)
- ValueObservation automatycznie trackuje changes i emituje updates

---

## 8. Analytics (`Analytics/`)

### AppAnalytics

**Responsibility:**
- Analytics facade
- Screen tracking
- Mode tracking (batch, single scan, etc.)
- User ID tracking
- Timestamp tracking

```swift
final class AppAnalytics {
    private let analytics: AnyFirebaseAnalytics
    private var screenName: String = "app_initialization"
    private var mode: String?
    private var userId: Int?

    func update(screenName: String, mode: String? = nil) {
        self.screenName = screenName
        self.mode = mode
    }

    func sendEnterForegroundEvent() {
        sendEvent(name: "app_enter_foreground")
    }

    func sendEnterBackgroundEvent() {
        sendEvent(name: "app_exit_foreground")
    }

    private func sendEvent(name: String) {
        var event = FirebaseEvent(name: name, params: [
            "timestamp": Date.now.timeIntervalSince1970 * 1000,
            "screen_name": screenName,
        ])

        if let mode {
            event = event.appending(paramName: "mode", value: mode)
        }

        if let userId {
            event = event.appending(paramName: "user_id", value: userId)
        }

        analytics.log(event: event)
    }
}
```

### FirebaseEvent

**Structure:**
```swift
struct FirebaseEvent {
    let name: String
    var params: [String: Any]

    func appending(paramName: String, value: Any) -> FirebaseEvent {
        var event = self
        event.params[paramName] = value
        return event
    }
}
```

### ModeFirebaseEvent

**Mode-Specific Events:**
```swift
extension ModeFirebaseEvent {
    static let batchModeScreen = make(screenName: "batch_mode")
    static let singleScanScreen = make(screenName: "single_scan")
    static let shelfScanScreen = make(screenName: "shelf_scan")

    static let captureButton = make(buttonName: "capture")
    static let uploadButton = make(buttonName: "upload")

    static func make(screenName: String) -> FirebaseEvent {
        FirebaseEvent(name: "screen_view", params: ["screen_name": screenName])
    }

    static func make(buttonName: String) -> FirebaseEvent {
        FirebaseEvent(name: "button_tap", params: ["button_name": buttonName])
    }
}
```

**Usage w TCA:**
```swift
@Dependency(\.firebaseAnalytics)
var analytics

case .onAppear:
    analytics.logMode(event: .batchModeScreen)

case .onCaptureButtonTapped:
    analytics.logMode(event: .captureButton)
```

---

## 9. Dependency System (`Dependency/`)

### ShelfDependencies (Legacy)

**⚠️ UWAGA:** To legacy system - prefer TCA `@Dependency` for new code!

**Implementation:**
```swift
final class ShelfDependencies {
    fileprivate static var shared = ShelfDependencies()
    private var storage: [ObjectIdentifier: Any] = [:]
    private let queue = DispatchQueue(label: "com.shelf.dependency-queue")

    subscript<Key: ShelfDependencyKey>(_: Key.Type) -> Key.Value {
        get {
            queue.sync {
                storage[ObjectIdentifier(Key.self)] as? Key.Value ?? Key.defaultValue
            }
        }
        set {
            queue.async {
                self.storage[ObjectIdentifier(Key.self)] = newValue
            }
        }
    }
}

protocol ShelfDependencyKey {
    associatedtype Value
    static var defaultValue: Value { get }
}

@propertyWrapper
struct ShelfDependency<Value> {
    private let keyPath: WritableKeyPath<ShelfDependencies, Value>

    var wrappedValue: Value {
        get { ShelfDependencies.shared[keyPath: keyPath] }
        set { ShelfDependencies.shared[keyPath: keyPath] = newValue }
    }
}
```

**Usage (Legacy):**
```swift
// Define key
enum CameraRepositoryKey: ShelfDependencyKey {
    static let defaultValue: CameraRepository = ShelfCameraRepository()
}

extension ShelfDependencies {
    var cameraRepository: CameraRepository {
        get { self[CameraRepositoryKey.self] }
        set { self[CameraRepositoryKey.self] = newValue }
    }
}

// Usage
@ShelfDependency(\.cameraRepository)
var cameraRepository: CameraRepository
```

**⚠️ Migration Path:**
- Nowy kod: używaj TCA `@Dependency` (już udokumentowane)
- Legacy kod: stopniowo migruj do TCA `@Dependency`
- Nie mix'uj obu systemów w tym samym komponencie

---

## Inne Kluczowe Services

### ScanditCaptureManager (`ScanditCaptureManager/`)
- `ScanditCaptureManager` - Scandit SDK integration
- `ShelfScanditCaptureManager` - app-specific wrapper
- `DataCaptureModes` - barcode/label capture modes

### RealityKit (`RealityKit/`)
- `ARKitController` - AR session management
- `FocusEntity` - AR focus indicator
- `BarcodeDetector` - AR barcode detection
- Animacje and constraints for AR entities

### Device (`DeviceMotionTracker/`)
- `DeviceMotionTracker` - CoreMotion integration
- `ShelfDeviceMotionTracker` - app-specific tracker
- Orientation i motion tracking

---

## Patterns and Best Practices

### 1. Dependency Injection Pattern

```swift
// Service z @Dependency
final class ShelfAccountStorage: AccountStorage {
    @Dependency(\.httpService) private var httpService
    @Dependency(\.database) private var database
    // ...
}

// Registration w DependencyValues
extension DependencyValues {
    var accountStorage: AccountStorage {
        get { self[AccountStorageKey.self] }
        set { self[AccountStorageKey.self] = newValue }
    }
}
```

### 2. Protocol-Based Design

```swift
// Protocol
protocol AccountStorage {
    var isLoggedIn: CurrentValueSubject<Bool, Never> { get }
    var apiToken: String? { get set }

    func login(email: String, password: String) -> AnyPublisher<Void, Error>
    func logout() async
}

// Implementation
final class ShelfAccountStorage: AccountStorage {
    // ...
}

// Fake for tests
final class FakeAccountStorage: AccountStorage {
    // ...
}
```

### 3. Endpoint Pattern

```swift
// 1. Define endpoint struct
struct MyEndpoint: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = MyRequest
    typealias ResponsePayload = MyResponse

    let path: String
    let method: HttpMethod
    let headers: [HttpHeader]
    let requestPayload: MyRequest
}

// 2. Call
httpService.request(endpoint: MyEndpoint(...))
    .sink { completion in /* ... */ }
    receiveValue: { response in /* ... */ }
```

### 4. Reactive Publishers z GRDB

```swift
var records: AnyPublisher<[Record], Error> {
    ValueObservation
        .tracking { database in
            try Record.fetchAll(database)
        }
        .publisher(in: writer, scheduling: .async(onQueue: .global()))
        .eraseToAnyPublisher()
}
```

### 5. Offline-First z Fallback

```swift
func fetchData() -> AnyPublisher<Data, Error> {
    networkCall()
        .handleEvents { data in
            cache.save(data)  // Cache success
        }
        .catch { error in
            if let cached = cache.load() {
                return Just(cached).setFailureType(to: Error.self)
            }
            return Fail(error: error)
        }
}
```

## Common Mistakes and Pitfalls

### ❌ DON'T do this:

```swift
// 1. Hardcoded API token
struct MyEndpoint: HttpEndpoint {
    let headers = [.authorization("hardcoded-token")]  // ❌
}

// 2. Blocking main thread w database
func fetchRecords() -> [Record] {
    try! database.writer.read { db in
        try Record.fetchAll(db)  // ❌ Blocks main thread!
    }
}

// 3. Nie cachowanie config
func fetchConfig() -> AnyPublisher<Config, Error> {
    httpService.request(endpoint: ConfigEndpoint(...))  // ❌ No offline support
}

// 4. Singleton state
class MyService {
    static var shared = MyService()  // ❌ Hard to test
    static var apiToken: String?     // ❌ Global mutable state
}
```

### ✅ DO this:

```swift
// 1. Token via constructor
init(apiToken: String) {
    self.headers = [.authorization(apiToken)]
}

// 2. Async database access
var records: AnyPublisher<[Record], Error> {
    ValueObservation
        .tracking { try Record.fetchAll($0) }
        .publisher(in: writer, scheduling: .async(onQueue: .global()))
}

// 3. Cache + fallback
fetchConfig()
    .handleEvents { cache.save($0) }
    .catch { _ in
        if let cached = cache.load() {
            return Just(cached).setFailureType(to: Error.self)
        }
        return Fail(error: error)
    }

// 4. Dependency Injection
@Dependency(\.myService) var myService  // ✅ Testable
```

## Testing Guidelines

### Service Tests
- Mock dependencies (HTTP, Database)
- Test error handling (network failures, 401, 429, 5xx)
- Test offline fallback logic
- Test publishers emit correct values

**Przykład:**
```swift
func testLoginSuccess() async throws {
    let mockHTTP = MockHTTPService()
    mockHTTP.registerResponse = DeviceToken(apiToken: "test-token")

    let storage = ShelfAccountStorage.makeWithDeps(httpService: mockHTTP)

    let result = try await storage.login(email: "test@example.com", password: "pass").firstAsync()

    XCTAssertEqual(storage.apiToken, "test-token")
    XCTAssertTrue(storage.isLoggedIn.value)
}
```

## Summary of Key Patterns

1. **Protocol-Based Services** - `AccountStorage`, `HttpService`, `AppDatabase`
2. **Dependency Injection** - TCA `@Dependency` for singletons
3. **Type-Safe Endpoints** - structs conforming to `HttpEndpoint`
4. **Reactive Publishers** - GRDB `ValueObservation` + Combine
5. **Offline-First** - network fetch + cache + fallback
6. **Error Mapping** - `ResponseError` + `GenericAPIResponseError`
7. **Environment Switching** - production/staging/custom
8. **Secure Storage** - Keychain for sensitive data
9. **Background Operations** - async scheduling for DB i uploads
10. **Testing Support** - in-memory database, mock services
