import { executePromise, clientError, clientValue, ClientResult } from "@/lib/error-handling"
import {
  SurveyResultDTO,
  CreateSurveyResultDTO,
  TallyWebhookPayload,
  TallyField,
} from "./survey-type"
import { findEmailField } from "./survey-field-utils"

export async function processTallyWebhookUseCase(props: {
  context: {
    saveSurveyResult: (data: CreateSurveyResultDTO) => Promise<SurveyResultDTO>
    evaluateTallyResponse: (fields: TallyField[]) => Promise<"approved" | "rejected">
  }
  data: TallyWebhookPayload
}): Promise<ClientResult<SurveyResultDTO>> {
  // Walidacja danych webhook
  if (!props.data.data || !props.data.data.fields) {
    return clientError("Invalid webhook payload - missing fields data")
  }

  // Znajdź email w odpowiedziach (jeśli jest) - type-safe
  const emailField = findEmailField(props.data.data.fields)

  // Oceń odpowiedzi
  const surveyResult = await props.context.evaluateTallyResponse(props.data.data.fields)

  // Przygotuj dane do zapisu - type-safe email extraction
  const createData: CreateSurveyResultDTO = {
    email: emailField?.value?.toString() || undefined,
    result: surveyResult,
    tallyResponseId: props.data.data.responseId,
  }

  // Zapisz wynik
  const saveResult = await executePromise(() => props.context.saveSurveyResult(createData))

  if (saveResult.isFailure) {
    return clientError("Failed to save survey result")
  }

  return clientValue(saveResult.value)
}

export async function getSurveyResultUseCase(props: {
  context: {
    getSurveyResult: (id: string) => Promise<SurveyResultDTO | null>
  }
  data: {
    id: string
  }
}): Promise<ClientResult<SurveyResultDTO>> {
  const result = await executePromise(() => props.context.getSurveyResult(props.data.id))

  if (result.isFailure) {
    return clientError("Failed to fetch survey result")
  }

  if (!result.value) {
    return clientError("Survey result not found")
  }

  return clientValue(result.value)
}
