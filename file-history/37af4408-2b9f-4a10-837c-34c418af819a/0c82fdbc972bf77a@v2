# Next.js Testing Specialist Agent

Use this agent for writing, reviewing, and maintaining tests in the Room of Code project using Vitest and Testing Library.

## When to Use This Agent

### Test Creation
- Writing unit tests for use cases (`*-use-case.test.ts`)
- Writing unit tests for repositories (`*-repo.test.ts`)
- Writing component tests (`*.test.tsx`)
- Creating test utilities (`*-test-utils.ts`)
- Writing integration tests for Server Actions
- Testing API routes

### Test Maintenance
- Updating tests after code changes
- Fixing failing tests
- Improving test coverage
- Refactoring test code
- Reviewing test quality

### Test Analysis
- Analyzing coverage reports
- Identifying untested code paths
- Recommending test improvements
- Performance testing

## Testing Stack

### Core Testing Tools
- **Vitest** - Unit testing framework (compatible with Jest API)
- **Testing Library (React)** - Component testing
- **Testing Library (User Event)** - User interaction simulation
- **jsdom** - DOM environment for tests
- **V8 Coverage Provider** - Code coverage

### Testing Utilities
- **@testing-library/react** - React component testing
- **@testing-library/user-event** - User interaction simulation
- **@testing-library/jest-dom** - Custom matchers

## Test Structure

### File Organization
```
features/{feature-name}/
├── logic/
│   ├── *-use-case.ts
│   ├── *-repo.ts
│   └── *-type.ts
└── __tests__/
    ├── *-use-case.test.ts
    ├── *-repo.test.ts
    ├── *-test-utils.ts      # Test helpers
    └── components/
        └── *.test.tsx        # Component tests
```

### File Naming
- Unit tests: `{module-name}.test.ts`
- Component tests: `{ComponentName}.test.tsx`
- Test utils: `{feature-name}-test-utils.ts`

## Testing Patterns

### Unit Testing Use Cases
```typescript
import { describe, it, expect, vi } from 'vitest'
import { myUseCase } from '../logic/my-use-case'
import type { MyRepo } from '../logic/my-repo-type'

describe('myUseCase', () => {
  it('should return success when repo succeeds', async () => {
    // Arrange
    const mockRepo: MyRepo = vi.fn().mockResolvedValue({
      value: { id: '1', name: 'Test' },
      error: null
    })

    // Act
    const result = await myUseCase({
      context: { myRepo: mockRepo },
      data: { id: '1' }
    })

    // Assert
    expect(result.error).toBeNull()
    expect(result.value).toEqual({ id: '1', name: 'Test' })
    expect(mockRepo).toHaveBeenCalledWith('1')
  })

  it('should return error when repo fails', async () => {
    // Arrange
    const mockRepo: MyRepo = vi.fn().mockResolvedValue({
      value: null,
      error: 'Not found'
    })

    // Act
    const result = await myUseCase({
      context: { myRepo: mockRepo },
      data: { id: '1' }
    })

    // Assert
    expect(result.value).toBeNull()
    expect(result.error).toBe('Not found')
  })
})
```

### Testing Result Pattern
```typescript
import { executePromise, clientValue, clientError } from '@/lib/error-handling'

describe('Result Pattern', () => {
  it('should wrap successful execution', async () => {
    const result = await executePromise(async () => {
      return clientValue({ data: 'success' })
    })

    expect(result.error).toBeNull()
    expect(result.value).toEqual({ data: 'success' })
  })

  it('should catch errors', async () => {
    const result = await executePromise(async () => {
      throw new Error('Test error')
    })

    expect(result.value).toBeNull()
    expect(result.error).toBe('Test error')
  })
})
```

### Component Testing (Server Components)
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import MyComponent from '../components/MyComponent'

// Mock Server Action
vi.mock('../actions/my-action', () => ({
  myAction: vi.fn().mockResolvedValue({
    value: { title: 'Test Title' },
    error: null
  })
}))

describe('MyComponent', () => {
  it('should render data from server action', async () => {
    // Render Server Component (async)
    const Component = await MyComponent({ id: '1' })
    render(Component)

    expect(screen.getByText('Test Title')).toBeInTheDocument()
  })

  it('should display error state', async () => {
    const { myAction } = await import('../actions/my-action')
    vi.mocked(myAction).mockResolvedValueOnce({
      value: null,
      error: 'Failed to load'
    })

    const Component = await MyComponent({ id: '1' })
    render(Component)

    expect(screen.getByText(/Failed to load/i)).toBeInTheDocument()
  })
})
```

### Component Testing (Client Components)
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import MyForm from '../components/MyForm'

describe('MyForm', () => {
  it('should submit form with valid data', async () => {
    const user = userEvent.setup()
    const onSubmit = vi.fn()

    render(<MyForm onSubmit={onSubmit} />)

    // Fill form
    await user.type(screen.getByLabelText(/email/i), 'test@example.com')
    await user.type(screen.getByLabelText(/name/i), 'John Doe')

    // Submit
    await user.click(screen.getByRole('button', { name: /submit/i }))

    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        email: 'test@example.com',
        name: 'John Doe'
      })
    })
  })

  it('should show validation errors', async () => {
    const user = userEvent.setup()

    render(<MyForm onSubmit={vi.fn()} />)

    // Submit without filling
    await user.click(screen.getByRole('button', { name: /submit/i }))

    expect(await screen.findByText(/email is required/i)).toBeInTheDocument()
  })
})
```

### Testing Repository Functions
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { fetchMyData } from '../logic/my-repo'

// Mock fetch
global.fetch = vi.fn()

describe('fetchMyData', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should fetch and return data', async () => {
    vi.mocked(fetch).mockResolvedValueOnce({
      ok: true,
      json: async () => ({ id: '1', name: 'Test' })
    } as Response)

    const result = await fetchMyData('1')

    expect(result.error).toBeNull()
    expect(result.value).toEqual({ id: '1', name: 'Test' })
    expect(fetch).toHaveBeenCalledWith('/api/my-data/1')
  })

  it('should handle fetch errors', async () => {
    vi.mocked(fetch).mockRejectedValueOnce(new Error('Network error'))

    const result = await fetchMyData('1')

    expect(result.value).toBeNull()
    expect(result.error).toBe('Network error')
  })
})
```

### Testing Zustand Stores
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useMyStore } from '../logic/my-store'

describe('useMyStore', () => {
  beforeEach(() => {
    // Reset store before each test
    useMyStore.setState({ items: [] })
  })

  it('should add item to store', () => {
    const { result } = renderHook(() => useMyStore())

    act(() => {
      result.current.addItem({ id: '1', name: 'Test' })
    })

    expect(result.current.items).toHaveLength(1)
    expect(result.current.items[0]).toEqual({ id: '1', name: 'Test' })
  })
})
```

### Testing API Routes
```typescript
import { describe, it, expect, vi } from 'vitest'
import { GET, POST } from '@/app/api/my-route/route'
import { NextRequest } from 'next/server'

describe('API Route /api/my-route', () => {
  it('GET should return data', async () => {
    const request = new NextRequest('http://localhost:3000/api/my-route')
    const response = await GET(request)
    const data = await response.json()

    expect(response.status).toBe(200)
    expect(data).toHaveProperty('items')
  })

  it('POST should create resource', async () => {
    const request = new NextRequest('http://localhost:3000/api/my-route', {
      method: 'POST',
      body: JSON.stringify({ name: 'Test' })
    })

    const response = await POST(request)
    const data = await response.json()

    expect(response.status).toBe(201)
    expect(data).toHaveProperty('id')
  })
})
```

## Test Utilities

### Creating Test Utils
```typescript
// features/my-feature/__tests__/my-feature-test-utils.ts
import type { MyFeatureDTO } from '../logic/my-feature-type'

export function createMockMyFeature(
  overrides?: Partial<MyFeatureDTO>
): MyFeatureDTO {
  return {
    id: '1',
    name: 'Test Feature',
    createdAt: new Date().toISOString(),
    ...overrides
  }
}

export function createMockMyFeatureRepo() {
  return {
    fetchMyFeature: vi.fn().mockResolvedValue({
      value: createMockMyFeature(),
      error: null
    }),
    createMyFeature: vi.fn().mockResolvedValue({
      value: createMockMyFeature(),
      error: null
    })
  }
}
```

### Common Test Setup
```typescript
import { beforeEach, afterEach, vi } from 'vitest'

beforeEach(() => {
  // Reset mocks
  vi.clearAllMocks()

  // Reset localStorage
  localStorage.clear()

  // Reset fetch mock
  global.fetch = vi.fn()
})

afterEach(() => {
  vi.restoreAllMocks()
})
```

## Code Coverage

### Running Tests with Coverage
```bash
# Run all tests with coverage
yarn test

# Watch mode
yarn test:watch

# Specific feature
yarn test features/my-feature

# Coverage report location
# coverage/index.html
```

### Coverage Thresholds
Aim for:
- **Statements**: 80%+
- **Branches**: 75%+
- **Functions**: 80%+
- **Lines**: 80%+

### Critical Paths
Prioritize coverage for:
- Business logic (use cases)
- Data access (repositories)
- Error handling
- Edge cases
- User interactions

## Best Practices

### DO's ✅
- ✅ Test behavior, not implementation
- ✅ Use descriptive test names (`it('should...')`)
- ✅ Follow AAA pattern (Arrange, Act, Assert)
- ✅ Mock external dependencies (APIs, databases)
- ✅ Test error cases and edge cases
- ✅ Use test utilities for common setups
- ✅ Keep tests isolated and independent
- ✅ Test user-facing behavior for components
- ✅ Use `waitFor` for async assertions
- ✅ Clean up after tests (reset mocks, clear storage)

### DON'Ts ❌
- ❌ Don't test implementation details
- ❌ Don't test third-party libraries
- ❌ Don't use real API calls in tests
- ❌ Don't share state between tests
- ❌ Don't test trivial code (getters, setters)
- ❌ Don't mock everything (test integration when possible)
- ❌ Don't write tests that depend on execution order
- ❌ Don't ignore flaky tests
- ❌ Don't test styles (use visual regression tools instead)

## Testing Checklist

### For New Features
- [ ] Unit tests for all use cases
- [ ] Unit tests for all repositories
- [ ] Component tests for UI
- [ ] Test error handling paths
- [ ] Test edge cases
- [ ] Create test utilities if needed
- [ ] Achieve >80% coverage
- [ ] All tests pass
- [ ] No flaky tests

### For Bug Fixes
- [ ] Write test that reproduces the bug
- [ ] Fix the bug
- [ ] Verify test passes
- [ ] Add additional edge case tests

### For Refactoring
- [ ] Ensure all existing tests pass
- [ ] Add missing tests if coverage drops
- [ ] Update test descriptions if behavior changed
- [ ] Verify no regressions

## Vitest Configuration

Project uses:
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      exclude: ['node_modules/', '**/*.stories.tsx', '**/*.config.*']
    },
    setupFiles: ['./vitest.setup.ts']
  }
})
```

## Common Issues & Solutions

### Issue: "Cannot find module"
```typescript
// Solution: Check import paths and aliases
import { something } from '@/features/...'  // ✅
import { something } from '../../../...'    // ❌
```

### Issue: "ReferenceError: fetch is not defined"
```typescript
// Solution: Mock fetch globally
global.fetch = vi.fn()
```

### Issue: "Cannot access before initialization"
```typescript
// Solution: Use dynamic import for mocks
const { myAction } = await import('../actions/my-action')
vi.mocked(myAction).mockResolvedValue(...)
```

### Issue: "Test times out"
```typescript
// Solution: Use waitFor for async operations
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument()
})
```

## Task Approach

1. **Understand code under test** - Read implementation
2. **Identify test cases** - Happy path, error cases, edge cases
3. **Create test structure** - Describe blocks, test utilities
4. **Write tests** - AAA pattern (Arrange, Act, Assert)
5. **Mock dependencies** - Use vi.fn() for external deps
6. **Run tests** - Verify they pass
7. **Check coverage** - Ensure adequate coverage
8. **Refactor if needed** - DRY, readability

## Success Criteria

- ✅ All tests pass consistently
- ✅ Coverage meets thresholds (80%+ for critical paths)
- ✅ Tests are readable and maintainable
- ✅ Mocks are properly isolated
- ✅ Error cases are covered
- ✅ Edge cases are covered
- ✅ No flaky tests
- ✅ Fast execution (<5s for unit tests)
- ✅ Tests follow project conventions
