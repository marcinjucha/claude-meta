---
description: How to write tests for screens, mock dependencies, test async behavior, and avoid common test pitfalls
globs: *Tests.swift,*Test.swift
---

# Presentation Layer Testing - Best Practices & Pitfalls

## When to use this guide

**This rule automatically applies in test files (*Tests.swift), and when you need:**
- test, testing, test this feature
- test view, test screen
- mock, spy, test double
- test async, test publisher, test loading
- test user interaction, button tap
- test failure, test error, debug test

**Natural examples:**
- "write tests for this feature"
- "test loading state behavior"
- "test button tap with async operation"
- "create test spy for use case"
- "test error handling in view"
- "debug failing test"

---

## ğŸš¨ Critical Pitfalls to Avoid

### âŒ NEVER: Use `skipInFlightEffects()` When No Effects Exist
```swift
// âŒ WRONG - Will cause "There were no in-flight effects to skip" error
await sut.send(.simpleAction) // No async effects
await sut.skipInFlightEffects() // âŒ ERROR - no effects to skip

// âœ… CORRECT - Only use when effects actually exist
await sut.send(.onAppear) // Has publisher subscriptions
await sut.skipInFlightEffects() // âœ… OK - effects exist
```

### âŒ NEVER: Ignore Unhandled Actions
```swift
// âŒ WRONG - Will cause test failures
await sut.send(.initialize) // Triggers multiple async actions but we ignore them

// âœ… CORRECT - Handle ALL resulting actions
await sut.send(.initialize) {
    $0.isLoaded = true
}
await sut.receive(\.reloadList)
await sut.receive(\.setupPublishers)
// OR use skipInFlightEffects() if effects exist but aren't relevant to test
```

### âŒ NEVER: Missing Dependencies in Tests
```swift
// âŒ WRONG - Will crash with "no test implementation" error
TestStore(initialState: Feature.State()) {
    Feature() // Uses @Dependency without mocking
}

// âœ… CORRECT - Mock all dependencies
TestStore(initialState: Feature.State()) {
    Feature()
} withDependencies: {
    $0.routeNavigation = NavigationMock()
    $0.uuid = .constant(UUID())
}
```

### âŒ NEVER: Initialize TestStore in setUp()
```swift
// âŒ WRONG - Don't initialize in setUp()
override func setUp() {
    sut = TestStore(...) // âŒ Use lazy var instead
}

// âœ… CORRECT - Use lazy var
lazy var sut = TestStoreOf<Feature>(initialState: Feature.State()) {
    Feature(useCase: useCase)
}
```

### âŒ NEVER: Test Publisher Timing Without Proper Mocking
```swift
// âŒ WRONG - Real publishers cause timing issues in tests
let realUseCase = RouteListUseCase() // Real publishers
TestStore(...) { Feature(useCase: realUseCase) }

// âœ… CORRECT - Use spy with controllable publishers
let useCase = RouteListUseCaseSpy() // Controllable subjects
useCase.stubbedRoutesPublisher.send(routes) // Deterministic timing
```

### âŒ NEVER: Ignore Publisher Lifecycle in Tests
```swift
// âŒ WRONG - Missing publisher setup/teardown
await sut.send(.onAppear) // Sets up publishers but we don't handle them
// Test continues without handling publisher effects

// âœ… CORRECT - Handle all publisher effects
await sut.send(.onAppear)
await sut.receive(\.reloadList) // Handle immediate effects
// Then trigger publisher emissions
useCase.stubbedRoutesPublisher.send(routes)
await sut.receive(\.updateRoutes) // Handle publisher effects
```

## ğŸ—ï¸ Essential Patterns

### TestStore Setup
```swift
// âœ… Standard pattern - lazy var with dependencies
@MainActor
final class RouteListFeatureTests: XCTestCase {
    let useCase = RouteListUseCaseSpy()
    lazy var sut = TestStoreOf<RouteListFeature>(initialState: RouteListFeature.State()) {
        RouteListFeature(useCase: useCase)
    }
}

// âœ… With dependencies block
lazy var sut: TestStoreOf<Feature> = .init(
    initialState: Feature.State(),
    reducer: { Feature(useCase: useCase) },
    withDependencies: {
        $0.navigation = NavigationMock()
        $0.uuid = .constant(UUID())
    }
)
```

### Action Handling
```swift
// âœ… ALWAYS use keypaths for receive()
await sut.receive(\.updateRoutes) {
    $0.routes = routes
    $0.showActivityIndicator = false
}

await sut.receive(\.reloadList) // No state changes
await sut.receive(\.navigateToAisle, aisle) // With value

// âœ… Child feature actions (from HomeStore example)
await sut.receive(\.storeSelection, .setup) {
    $0.storeSelection.showActivityIndicator = true
}
await sut.receive(\.storeSelection, .fetchStores)
await sut.receive(\.storeSelection, .dismissErrorMessage) {
    $0.storeSelection.showActivityIndicator = false
}

// âœ… Direct actions for send()
await sut.send(.onAppear) {
    $0.isLoaded = true
}
```

## ğŸ§ª Testing Strategy

### Dual-Layer Approach
```swift
// 1. PRESENTATION LAYER - Mock everything (Fast & Isolated)
@MainActor
final class RouteListFeatureTests: XCTestCase {
    let useCase = RouteListUseCaseSpy() // â† Mocked
    // Test TCA logic, UI behavior, state transitions
}

// 2. BUSINESS LAYER - Real components, mock external only
final class RouteListUseCaseTests: XCTestCase {
    let database = ShelfDatabase.inMemory() // â† Real
    let httpService = FakeHttpService() // â† Mock external
    // Test business logic, data flow, integration
}
```

### Publisher Testing
```swift
func testPublisherSubscription() async {
    await sut.send(.onAppear)
    await sut.receive(\.reloadList)

    // Send data through stubbed publisher
    let routes = [Route.sample()]
    useCase.stubbedRoutesPublisher.send(routes)

    await sut.receive(\.updateRoutes) {
        $0.routes = routes
    }
}

// âœ… Testing Loading State Publishers
func testStoreChangeLoadingState() async {
    await sut.send(.initialize) {
        $0.isLoaded = true
    }
    await sut.receive(\.reloadList)

    // Simulate store change loading start
    useCase.stubbedStoreChangeLoadingState.send(true)
    await sut.receive(\.storeChangeLoadingStateChanged, true) {
        $0.routes = []
        $0.isLoaded = false
        $0.showActivityIndicator = true
    }

    // Simulate loading completion
    useCase.stubbedStoreChangeLoadingState.send(false)
    await sut.receive(\.storeChangeLoadingStateChanged, false)

    // Then routes arrive
    useCase.stubbedRoutesPublisher.send([Route.sample()])
    await sut.receive(\.updateRoutes) {
        $0.routes = [Route.sample()]
        $0.showActivityIndicator = false
    }
}
```

### Test Data Helpers
```swift
// âœ… Deterministic test data
private func makeIncompleteRoute() -> Route {
    Route.sample(aisles: [
        RouteAisle.sample(modules: [
            RouteAisleModule.sample(captured: true),
            RouteAisleModule.sample(captured: false) // Not complete
        ])
    ])
}
```

## ğŸ› Debugging Test Failures

### Common Test Failure Patterns

#### "There were no in-flight effects to skip"
```swift
// âŒ Problem: Using skipInFlightEffects() when no effects exist
await sut.send(.simpleAction)
await sut.skipInFlightEffects() // âŒ No effects to skip

// âœ… Solution: Only use when effects actually exist
await sut.send(.onAppear) // Has publisher subscriptions
await sut.skipInFlightEffects() // âœ… Effects exist
```

#### "Unhandled action received"
```swift
// âŒ Problem: Action triggered but not handled in test
await sut.send(.initialize) // Triggers .reloadList but we don't handle it

// âœ… Solution: Handle all resulting actions
await sut.send(.initialize) {
    $0.isLoaded = true
}
await sut.receive(\.reloadList) // Handle the triggered action
```

#### "Expected state change but none occurred"
```swift
// âŒ Problem: Wrong state expectations
await sut.send(.updateRoutes, routes) {
    $0.isLoading = false // âŒ This property doesn't exist or isn't changed
}

// âœ… Solution: Check actual state changes in reducer
await sut.send(.updateRoutes, routes) {
    $0.routes = routes
    $0.showActivityIndicator = false // âœ… Correct property
}
```

### Debugging Strategies

#### 1. Enable Exhaustive Testing
```swift
// âœ… Add to test setup for detailed failure info
sut.exhaustivity = .on
```

#### 2. Use Print Debugging in Tests
```swift
// âœ… Temporary debugging in tests
await sut.send(.action) {
    print("State before: \($0)")
    $0.property = newValue
    print("State after: \($0)")
}
```

#### 3. Check Publisher Emissions
```swift
// âœ… Verify spy publishers are working
XCTAssertTrue(useCase.stubbedRoutesPublisher.hasSubscribers)
useCase.stubbedRoutesPublisher.send(routes)
// Then check if action is received
```

#### 4. Test Publisher Lifecycle
```swift
// âœ… Test complete publisher lifecycle
func testPublisherLifecycle() async {
    // Setup
    await sut.send(.onAppear)
    await sut.receive(\.reloadList)

    // Emit data
    useCase.stubbedRoutesPublisher.send(routes)
    await sut.receive(\.updateRoutes) { $0.routes = routes }

    // Teardown
    await sut.send(.onDisappear)
    // Verify no more emissions after cancellation
    useCase.stubbedRoutesPublisher.send([])
    // Should not receive updateRoutes action
}
```

## ğŸ“‹ Quick Reference

### âŒ CRITICAL PITFALLS:
- **`skipInFlightEffects()` when no effects exist** â†’ "no in-flight effects to skip" error
- **Ignoring unhandled actions** â†’ Test failures
- **Missing dependencies** â†’ "no test implementation" crash
- **TestStore in setUp()** â†’ Use lazy var instead

### âœ… ESSENTIAL PATTERNS:
- **Use `@MainActor`** for TCA feature tests
- **Always use keypaths** for `receive()`: `await sut.receive(\.action)`
- **Mock all dependencies** in `withDependencies` block
- **Handle ALL actions** or use `skipInFlightEffects()` when effects exist
- **Use lazy vars** for TestStore initialization
- **Test complete user journeys** with descriptive names

### ğŸ”§ SYNTAX REMINDERS:
```swift
// âœ… Correct TCA syntax
await sut.send(.action) { $0.property = value }
await sut.receive(\.action) { $0.property = value }
await sut.receive(\.action, expectedValue)

// âœ… TestStore setup
lazy var sut = TestStoreOf<Feature>(initialState: Feature.State()) {
    Feature(useCase: useCase)
}
```

## ğŸ’¬ Code Comments in Tests

> **See Architecture Essentials for complete comment guidelines** (applies to all code, including tests)

**Key principle**: Comments explain **WHY**, never **WHAT**. Self-documenting code beats commented code.

### Test-Specific Scenarios for Comments

**When to comment in tests:**
- **Hidden timing dependencies**: Critical delays that prevent race conditions
- **Counter-intuitive mock behavior**: Mocks that behave unexpectedly for good reasons
- **Specific test data patterns**: Data that triggers edge cases or bugs

**When NOT to comment in tests:**
- Test flow descriptions (`// Send initialize action` - test name should explain)
- Standard TCA patterns (`await sut.send()`, `await sut.receive()`)
- Mock setup (`mockUseCase.stubbedResponse = data` - obvious from code)

### Example: Test-Specific Complex Logic
```swift
// âœ… GOOD - Hidden timing dependency in tests
func testComplexPublisherChainWithHiddenDependency() async {
    // 50ms delay critical - without it, race condition occurs where
    // storeChangeLoadingState(false) arrives before updateRoutes
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
        useCase.stubbedStoreChangeLoadingState.send(false)
    }
    await sut.send(.initialize) { $0.isLoaded = true }
}
```

**Remember: TCA testing verifies complete user workflows through state transitions. Always run tests first to see actual behavior, then match expectations.**