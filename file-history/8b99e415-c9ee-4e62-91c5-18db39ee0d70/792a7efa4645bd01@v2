---
description: Code organization, where to put logic, separating responsibilities, structuring features, and dependency patterns
---
# Code Organization & Structure - Digital Shelf iOS

## When to use this guide

**Keywords that trigger this:**
- structure, organize, layers
- where to put logic, service or repository
- business logic, data access
- code organization, file structure
- separate concerns

**Natural examples:**
- "how should I structure the route filtering feature?"
- "where should route sorting logic go?"
- "should I use service or just repository?"
- "I need to combine data from 3 sources"
- "where does this calculation belong?"

---

## üèóÔ∏è Core Architecture

### Four-Layer Clean Architecture
**Presentation ‚Üí Business ‚Üí Data ‚Üí Models**

Each layer depends only on layers below it, never above:
```
Presentation (SwiftUI + TCA)
    ‚Üì depends on
Business (Use Cases + Services)
    ‚Üì depends on
Data (Repositories)
    ‚Üì depends on
Models (Domain Entities)
```

**Why This Matters:**
- **Testability**: Each layer can be tested independently
- **Maintainability**: Changes in one layer don't cascade to others
- **Flexibility**: Replace implementations without breaking dependents

---

## üì¶ Layer Responsibilities

### Models Layer (Domain)
- **Purpose**: Pure business entities without dependencies
- **Contents**: `Route`, `User`, `Store`, `UploadStatus`
- **Location**: `DigitalShelf/Models/`
- **Rules**:
  - Must be `Equatable` for TCA state
  - Add `Codable` only if serialized
  - Include `.sample()` factory for tests

### Repository Layer (Data Access)
- **Purpose**: Single-responsibility data operations
- **Pattern**: One repository per data source
- **Types**:
  - **Data Repository**: Database CRUD (GRDB)
  - **Network Repository**: API calls (HttpService)
  - **Shared Repository**: In-memory state shared across features
- **Critical Rule**: Repositories NEVER depend on other repositories
- **Location**: `DigitalShelf/Screens/[Feature]/Repository/`

**Why Repositories Don't Depend on Each Other:**
Prevents circular dependencies and keeps responsibilities clear. If you need multiple repositories, use a Service.

### Service Layer (Business Logic)
- **Purpose**: Combines multiple repositories OR complex algorithms
- **When to Use**:
  - Combining 2+ repositories (prevents dependency cycles)
  - Complex business algorithms (badge calculation, data fusion)
  - Domain-specific logic reused across features
- **Examples**:
  - `RouteWithHistoryService` - combines 5 repositories
  - `HomeModeService` - combines 3 repositories + mode creation logic
- **Location**: `DigitalShelf/Services/[Feature]/`

### Use Case Layer (Orchestration)
- **Purpose**: Thin coordination between Services/Repositories and Presentation
- **Responsibilities**:
  - Delegate to Services/Repositories
  - Expose publishers for reactive data
  - Simple data transformations
- **What NOT to Put Here**: Complex algorithms (use Service instead)
- **Location**: `DigitalShelf/Screens/[Feature]/Use Case/`

### Presentation Layer (UI + State)
- **Purpose**: User interface and state management
- **Components**:
  - **Feature Store** (TCA): State + Actions + Reducer
  - **View** (SwiftUI): Layout + Store binding
- **Location**: `DigitalShelf/Screens/[Feature]/Presentation/`

---

## üîÄ Decision Trees

### When to Use Service vs Use Case?

**Step-by-step decision:**

1. **Does it access data?**
   - YES, single source (DB OR API) ‚Üí **Create Repository**
   - YES, multiple sources ‚Üí Go to step 2
   - NO ‚Üí Go to step 3

2. **Need to combine multiple repositories?**
   - YES ‚Üí **Create Service**
   - NO ‚Üí Go to step 3

3. **Is there complex business logic?**
   - YES (algorithms, calculations, filtering) ‚Üí **Create Service**
   - NO (just delegates/coordinates) ‚Üí **Create Use Case**

**Quick Rules:**
```
Repository: Single data source (DB or API)
Service:    Multiple repos OR complex algorithm
Use Case:   Thin orchestration, exposes publishers to TCA
```

**Examples:**
- 2+ repos needed? ‚Üí **Service** (prevents cycles)
- Badge calculation logic? ‚Üí **Service** (algorithm)
- Just coordinate Service ‚Üí Repo? ‚Üí **Use Case** (thin)
- Expose publishers to TCA? ‚Üí **Use Case** (bridge)

---

## üìê Code Organization

### File Structure Pattern
```
Feature/
‚îú‚îÄ‚îÄ Model/           # Domain entities (if feature-specific)
‚îú‚îÄ‚îÄ Repository/      # Data access (DB, API, cache)
‚îú‚îÄ‚îÄ Service/         # Business logic (if needed)
‚îú‚îÄ‚îÄ Use Case/        # Orchestration
‚îî‚îÄ‚îÄ Presentation/    # TCA Feature + SwiftUI View
    ‚îú‚îÄ‚îÄ FeatureStore.swift
    ‚îî‚îÄ‚îÄ FeatureView.swift
```

### Naming Conventions
- **Models**: `Route`, `User`, `UploadStatus`
- **Features**: `RouteListFeature`, `HomeFeature`
- **Views**: `RouteListView`, `HomeView`
- **Use Cases**: `RouteListUseCase`, `HomeUseCase`
- **Repositories**: `RouteDataRepository`, `RouteNetworkRepository`
- **Services**: `RouteWithHistoryService`, `HomeModeService`

### File Organization (Within Classes)
Strict order for consistency:
1. **Static properties/methods**
2. **Instance properties** (public ‚Üí internal ‚Üí private)
3. **Lifecycle** (init, deinit)
4. **Methods** (public ‚Üí internal ‚Üí private)
5. **Extensions with nested types** (separate from main declaration)

---

## üèõÔ∏è SOLID Principles in Practice

### Single Responsibility Principle (SRP)
- **Rule**: Each class has one reason to change
- **Example**: `RouteWithHistoryService` (data fusion) vs `RouteRefreshService` (refresh operations)
- **Decision**: Split when responsibilities become clear, not prematurely

### Dependency Inversion Principle (DIP)
- **Rule**: Depend on abstractions (`@Dependency`), not concretions
- **Pattern**: Use protocols + dependency injection
- **Example**: `@Dependency(\.apiClient)` instead of `let apiClient = HTTPClient()`
- **Critical**: Capture dependencies before TaskGroup (see Critical Rules)

### Interface Segregation Principle (ISP)
- **Rule**: Focused protocols, not monolithic interfaces
- **Example**: `AnyRouteRefreshService` vs `AnyRouteHistoryService` (separate concerns)
- **Balance**: Don't create too many tiny protocols

### Open/Closed Principle (OCP)
- **Rule**: Open for extension, closed for modification
- **Pattern**: Use protocols + dependency injection for flexibility
- **Balance**: Don't over-abstract; keep it simple when possible

### Liskov Substitution Principle (LSP)
- **Rule**: Protocol implementations must honor contracts
- **Example**: All `AnyRepository` implementations behave consistently
- **Practice**: Don't throw unexpected errors or change behavior significantly

---

## üîß Dependency Injection Pattern

### Standard Pattern
```swift
// Production code - uses @Dependency
final class HomeUseCase: AnyHomeUseCase {
    @Dependency(\.modeService) private var modeService
    @Dependency(\.storeRepository) private var storeRepository

    init() {} // No manual injection
}

// Test code - uses makeWithDeps factory
#if DEBUG
extension HomeUseCase {
    static func makeWithDeps(
        modeService: AnyModeService,
        storeRepository: StoreRepository
    ) -> HomeUseCase {
        withDependencies {
            $0.modeService = modeService
            $0.storeRepository = storeRepository
        } operation: { HomeUseCase() }
    }
}
#endif
```

**Why This Pattern:**
- Production code stays clean (no test dependencies)
- Tests can inject mocks easily
- `#if DEBUG` keeps factories out of release builds

### Advanced Dependency Registration
```swift
enum MyDependencyKey: DependencyKey {
    static var liveValue: MyDependencyProtocol = MyDependency()
    #if DEBUG
    static var testValue: MyDependencyProtocol = MyDependency()
    #endif
}

extension DependencyValues {
    var myDependency: MyDependencyProtocol {
        get { self[MyDependencyProtocol.self] }
        set { self[MyDependencyProtocol.self] = newValue }
    }
}
```

---

## üéØ Best Practices

### Composition over Inheritance
- **Prefer**: Protocol composition + dependency injection
- **Avoid**: Deep class hierarchies
- **Example**: Service combining repositories vs inheriting from base service

### Fail Fast Principle
- **Use**: Guard statements for invalid state
- **Example**: `guard let storeId = storeRepository.activeStoreId else { return }`
- **Balance**: Graceful degradation for user-facing features

### Don't Repeat Yourself (DRY)
- **Extract**: Common logic to services, extensions, utilities
- **Timing**: Wait for clear patterns before abstracting
- **Balance**: Don't abstract too early (3+ uses = abstract)

### Code Comments Best Practices

**Universal Rule (Applies to ALL Code):**
Comments should explain **WHY**, never **WHAT**. Self-documenting code is more maintainable than commented code.

#### When to Comment (Complex Logic Only)
- **Complex algorithms**: Non-obvious business logic or calculations
- **Race conditions**: Timing-sensitive operations that need explanation
- **Business decisions**: Architectural choices that aren't obvious from code
- **Hidden dependencies**: Non-obvious relationships between components

#### When NOT to Comment (Self-Documenting Code)
- **Obvious operations**: Setting properties, calling methods with clear names
- **Standard patterns**: TCA actions, publisher subscriptions, standard Swift
- **Variable assignments**: Clear variable names eliminate need for comments
- **Simple logic**: If-else, guards, loops with descriptive conditions

#### Examples Across All Layers

**‚ùå BAD - Obvious Comments (Remove These)**
```swift
// Repository Layer
// Set loading state to true
state.isLoading = true

// Save the route to database
try route.save(db)

// Service Layer
// Get active store ID
let storeId = storeRepository.activeStoreId

// Use Case Layer
// Return routes publisher
return routesPublisher

// TCA Layer
// Send initialize action
await send(.initialize)

// Handle routes update
case .routesUpdated(let routes):
    state.routes = routes

// Tests
// Create test route
let route = Route.sample()
```

**‚úÖ GOOD - Complex Logic Comments (Keep These)**
```swift
// Repository Layer - Complex query logic
func routesWithPendingUploads() -> AnyPublisher<[Route], Error> {
    // Group by 15-second windows to prevent duplicate processing
    // of rapid successive uploads in same session
    ValueObservation
        .tracking { db in
            let recentUploads = try Upload
                .filter(Column("timestamp") > Date().addingTimeInterval(-15))
                .fetchAll(db)
            // ... complex grouping logic
        }
}

// Service Layer - Race condition handling
private func handleStoreChange(newStoreId: Store.ID?) async {
    // Critical: Use publisher value directly, not repository property
    // Repository property may be stale during publisher emission
    guard let storeId = newStoreId else { return }
    // ...
}

// Service Layer - Complex algorithm
private func calculateBadge(for route: Route) -> RouteBadge? {
    // Priority: uploadPending ‚Üí uploading(progress) ‚Üí failure ‚Üí lastCaptured
    // Network offline changes uploading to pending to avoid confusion
    let allModuleStatuses = route.aisles.flatMap { $0.modules.compactMap(\.uploadStatus) }
    // ...
}

// TCA Layer - Publisher timing
case .onAppear:
    // Setup persistent publishers (store/network) in initialize
    // Setup view-specific publishers here to allow cancellation on navigation
    return .publisher {
        useCase.routesPublisher.map(Action.updateRoutes)
    }
    .cancellable(id: CancelID.routes)

// Tests - Non-obvious test setup
func testComplexPublisherTiming() async {
    // 50ms delay critical - without it, race condition occurs where
    // storeChangeLoadingState(false) arrives before updateRoutes
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
        useCase.stubbedLoadingState.send(false)
    }
}
```

#### Self-Documenting Code Principles
```swift
// ‚úÖ GOOD - Descriptive names eliminate comments
func testStoreChangeLoadingStateSpinnerControl() async {
    // No comment needed - test name explains intent
}

let isStoreChangeInProgress = true
// vs
let flag = true  // ‚ùå Needs comment to explain

case .storeChangeLoadingStateChanged(Bool)
// vs
case .update(Bool)  // ‚ùå Needs comment to explain
```

**Remember: If you need a comment to explain WHAT code does, rename variables/methods instead. Only comment WHY when logic is genuinely complex.**

---

## ‚úÖ Architecture Checklist

### Before Starting Feature
- [ ] Identified which layers are needed (Models, Repo, Service, UseCase, TCA)
- [ ] Decided Service vs Use Case based on decision tree
- [ ] Planned repository responsibilities (no cross-repo dependencies)
- [ ] Designed data flow (publishers vs one-time effects)

### During Implementation
- [ ] Each component has single responsibility
- [ ] Dependencies use `@Dependency` + `makeWithDeps`
- [ ] Repositories don't depend on other repositories
- [ ] Services combine multiple repositories OR handle complex algorithms
- [ ] Use Cases are thin orchestration layers

### Before Committing
- [ ] File organization follows standard order
- [ ] Naming conventions followed
- [ ] No obvious comments (only WHY, not WHAT)
- [ ] `makeWithDeps` wrapped in `#if DEBUG`
- [ ] Tests verify architecture boundaries

---

## üéØ Quick Reference

**Architecture**: Clean Architecture (4 layers)
**Dependency Rule**: Higher layers depend on lower layers only
**Repository Rule**: Never depend on other repositories
**Service vs UseCase**: Service = multiple repos OR complex logic; UseCase = orchestration
**Dependency Injection**: `@Dependency` + `makeWithDeps` pattern
**Comments**: Only WHY, never WHAT

**Remember: Clarity in architecture leads to maintainable code.**
