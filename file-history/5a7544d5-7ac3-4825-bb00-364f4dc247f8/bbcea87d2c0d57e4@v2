# Claude Commands - Przewodnik UÅ¼ytkownika

> Kompletny przewodnik po komendach Claude Code dla projektu Next.js z feature-based architecture

## ğŸ“‹ Spis TreÅ›ci

1. [Szybki Start](#szybki-start)
2. [Komendy Deweloperskie](#komendy-deweloperskie)
3. [Komendy Quality Assurance](#komendy-quality-assurance)
4. [Komendy Generowania Kodu](#komendy-generowania-kodu)
5. [PrzykÅ‚adowe Workflow](#przykÅ‚adowe-workflow)
6. [Integracja z Agentami](#integracja-z-agentami)

---

## Szybki Start

Wszystkie komendy uruchamiasz w Claude Code przez prefiks `/`:

```bash
/feature product "CRUD for products"
/lint features/product/
/test features/product/logic/product-use-case.ts
```

---

## Komendy Deweloperskie

### `/debug` - Debugowanie Kodu

**Opis**: Analizuje kod pod kÄ…tem bÅ‚Ä™dÃ³w i proponuje strategie debugowania.

**SkÅ‚adnia**:
```bash
/debug [Å›cieÅ¼ka_do_pliku] [opcjonalny_opis_bÅ‚Ä™du]
```

#### PrzykÅ‚ad 1: BÅ‚Ä…d executePromise
```bash
/debug features/product/logic/product-use-case.ts "executePromise nie Å‚apie bÅ‚Ä™dÃ³w z GraphQL"
```

**ZwrÃ³ci**:
- AnalizÄ™ przepÅ‚ywu bÅ‚Ä™dÃ³w przez warstwy
- Sprawdzenie czy `handleGraphQLMutation` rzuca bÅ‚Ä™dy
- WeryfikacjÄ™ wrapper `executePromise`
- Konkretne miejsca do debugowania (breakpointy, console.log)

#### PrzykÅ‚ad 2: Server Action nie dziaÅ‚a
```bash
/debug features/checkout/actions/checkout-actions.ts "Server Action zwraca undefined"
```

**ZwrÃ³ci**:
- Sprawdzenie dyrektywy `"use server"`
- WeryfikacjÄ™ konwersji FormData
- Sprawdzenie czy ClientResult jest zwracany
- Debugging redirect issues

#### PrzykÅ‚ad 3: Komponent nie renderuje
```bash
/debug features/product/components/product-form.tsx "formularz nie wyÅ›wietla bÅ‚Ä™dÃ³w walidacji"
```

**ZwrÃ³ci**:
- Sprawdzenie `"use client"` directive
- React Hook Form setup
- Zod schema validation
- `setError("root")` usage

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Gdy coÅ› nie dziaÅ‚a i nie wiesz dlaczego
- âœ… BÅ‚Ä™dy w konsoli sÄ… niejasne
- âœ… Server Actions nie wykonujÄ… siÄ™
- âœ… GraphQL mutations failujÄ…
- âœ… React Hook Form validation nie dziaÅ‚a

---

### `/explain` - WyjaÅ›nienie Kodu

**Opis**: SzczegÃ³Å‚owe wyjaÅ›nienie architektury i implementacji kodu.

**SkÅ‚adnia**:
```bash
/explain [Å›cieÅ¼ka_do_pliku]
```

#### PrzykÅ‚ad 1: WyjaÅ›nienie Use Case
```bash
/explain features/order/logic/order-use-case.ts
```

**ZwrÃ³ci**:
- IdentyfikacjÄ™ warstwy (Business Logic)
- WyjaÅ›nienie przepÅ‚ywu danych
- AnalizÄ™ executePromise wrappera
- Dependency injection context
- Orchestration pattern
- Business rules dokumentacjÄ™

#### PrzykÅ‚ad 2: WyjaÅ›nienie Server Action
```bash
/explain features/checkout/actions/checkout-actions.ts
```

**ZwrÃ³ci**:
- WyjaÅ›nienie walidacji Zod
- Dependency injection do Use Case
- ClientResult handling
- Redirect strategy
- Error propagation

#### PrzykÅ‚ad 3: WyjaÅ›nienie Repository
```bash
/explain features/product/logic/product-repo.ts
```

**ZwrÃ³ci**:
- GraphQL mutations/queries
- Fragment usage
- Response â†’ DTO mapping
- makeAssetUrl usage
- Error throwing strategy

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Onboarding nowych czÅ‚onkÃ³w zespoÅ‚u
- âœ… Code review - zrozumienie implementacji
- âœ… Dokumentowanie decyzji architektonicznych
- âœ… Nauka wzorcÃ³w projektu

---

## Komendy Quality Assurance

### `/lint` - Code Quality Check

**Opis**: Kompleksowa analiza jakoÅ›ci kodu pod kÄ…tem architektury, wzorcÃ³w i code smells.

**SkÅ‚adnia**:
```bash
/lint [Å›cieÅ¼ka_do_pliku_lub_folderu]
```

#### PrzykÅ‚ad 1: Lint pojedynczego Use Case
```bash
/lint features/product/logic/product-use-case.ts
```

**Sprawdzi**:
- âœ… Czy wszystkie external calls majÄ… `executePromise`
- âœ… Czy zwraca `ClientResult`
- âœ… Czy dependency injection jest wÅ‚aÅ›ciwy
- âœ… Czy brak business logic w zÅ‚ej warstwie
- âœ… Czy typy sÄ… poprawnie zorganizowane

**PrzykÅ‚adowy output**:
```
âš ï¸ ISSUES FOUND:

1. Missing executePromise wrapper (line 23)
   Current: const result = await props.context.repository(data)
   Should be: const result = await executePromise(() => props.context.repository(data))

2. Wrong type organization (line 5)
   ProductResponse should be internal in repository, not exported from product-type.ts
```

#### PrzykÅ‚ad 2: Lint caÅ‚ego feature
```bash
/lint features/checkout/
```

**Sprawdzi**:
- Architecture compliance (wszystkie warstwy)
- Type organization
- No layer skipping
- Test coverage
- Comment quality

#### PrzykÅ‚ad 3: Lint przed commitem
```bash
/lint features/order/
```

**UÅ¼yj przed**:
- `git commit` - catch issues early
- Code review request
- Merge do main branch

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Przed kaÅ¼dym commitem
- âœ… Po implementacji nowej logiki
- âœ… Code review preparation
- âœ… Refactoring validation

---

### `/review-pr` - Pull Request Readiness

**Opis**: Kompleksowy checklist przed utworzeniem Pull Requesta.

**SkÅ‚adnia**:
```bash
/review-pr [Å›cieÅ¼ka_do_feature_lub_folderu]
```

#### PrzykÅ‚ad 1: Review caÅ‚ego feature przed PR
```bash
/review-pr features/product/
```

**Sprawdzi**:
```
âœ… PASSED CHECKS:
- Layer separation correct
- executePromise used everywhere
- Tests exist and pass
- No commented code

âš ï¸ ISSUES TO FIX:
1. Missing test for product-use-case error handling
2. TODO comment in product-actions.ts:45
3. Console.log in product-form.tsx:67 (debug statement)

âŒ CRITICAL ISSUES:
1. Component directly calls Repository (product-form.tsx:89)
   Must go through Server Action â†’ Use Case â†’ Repository
```

#### PrzykÅ‚ad 2: Quick check pojedynczego pliku
```bash
/review-pr features/checkout/actions/checkout-actions.ts
```

#### PrzykÅ‚ad 3: Review przed merge
```bash
/review-pr features/
```

**UÅ¼yj przed**:
- Utworzeniem PR
- Mergem do production branch
- Release deployment

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Przed utworzeniem PR (zawsze!)
- âœ… Po code review fixes
- âœ… Przed mergem do main
- âœ… Production readiness check

---

## Komendy Generowania Kodu

### `/feature` - Generowanie Nowego Feature

**Opis**: Tworzy kompletnÄ… strukturÄ™ nowego feature z wszystkimi plikami.

**SkÅ‚adnia**:
```bash
/feature [nazwa_feature] [opcjonalny_opis]
```

#### PrzykÅ‚ad 1: Proste CRUD feature
```bash
/feature product "Product management with CRUD operations"
```

**Wygeneruje**:
```
features/product/
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ product-actions.ts          # Server Actions + Zod
â”œâ”€â”€ components/
â”‚   â””â”€â”€ product-form.tsx            # React Hook Form component
â”œâ”€â”€ logic/
â”‚   â”œâ”€â”€ product-use-case.ts         # Business logic
â”‚   â”œâ”€â”€ product-repo.ts             # GraphQL repository
â”‚   â””â”€â”€ product-type.ts             # DTO types
â””â”€â”€ __tests__/
    â”œâ”€â”€ product-actions.test.ts     # Actions tests
    â”œâ”€â”€ product-use-case.test.ts    # Use Case tests
    â””â”€â”€ product-test-utils.ts       # Test fixtures
```

**KaÅ¼dy plik zawiera**:
- Proper layer patterns
- executePromise + ClientResult
- Dependency injection
- GraphQL setup with fragments
- Complete tests

#### PrzykÅ‚ad 2: Feature z image upload
```bash
/feature user-profile "User profile with avatar upload"
```

**Wygeneruje dodatkowo**:
- File upload handling w repository
- Multi-step Use Case (upload â†’ update)
- Form z file input

#### PrzykÅ‚ad 3: Feature z complex business logic
```bash
/feature order "Order processing with payment and inventory"
```

**Wygeneruje**:
- Multi-step Use Case orchestration
- Multiple repository dependencies
- Complex error handling

#### Po wygenerowaniu:
1. **Review** wygenerowany kod
2. **Dostosuj** business logic do potrzeb
3. **Uruchom testy**: `npm test features/[feature]`
4. **Lint**: `/lint features/[feature]/`

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Tworzenie nowego feature od zera
- âœ… Prototypowanie
- âœ… Nauka wzorcÃ³w projektu (uÅ¼yj jako reference)
- âœ… Szybki start z boilerplate

---

### `/test` - Generowanie TestÃ³w

**Opis**: Generuje kompleksowe testy dla Actions i Use Cases.

**SkÅ‚adnia**:
```bash
/test [Å›cieÅ¼ka_do_pliku] [opcjonalny_fokus]
```

#### PrzykÅ‚ad 1: Testy dla Use Case
```bash
/test features/product/logic/product-use-case.ts
```

**Wygeneruje**:
```typescript
// features/product/__tests__/product-use-case.test.ts

describe("Product Use Case", () => {
  it("should create product successfully", async () => {
    // Mock GraphQL
    vi.mocked(client.mutate).mockResolvedValue(
      createMockProductGraphQLResponse({ title: "Test Product" })
    )

    const context = { repository: createProductRepository }
    const result = await createProductUseCase({ context, data })

    expect(result.isFailure).toBe(false)
    expect(result.value.title).toBe("Test Product")
  })

  it("should handle GraphQL errors", async () => {
    vi.mocked(client.mutate).mockRejectedValue(new Error("GraphQL failed"))
    // ... test error handling
  })

  it("should handle validation errors", async () => {
    // ... test validation
  })

  it("should handle missing data", async () => {
    // ... test empty response
  })
})
```

#### PrzykÅ‚ad 2: Testy dla Actions
```bash
/test features/product/actions/product-actions.ts
```

**Wygeneruje**:
```typescript
// Mock Use Case
vi.mock("../logic/product-use-case", () => ({
  createProductUseCase: vi.fn(),
}))

describe("Product Actions", () => {
  it("should validate and call use case", async () => {
    const mockResult = { isFailure: false, value: { id: "123" } }
    vi.mocked(createProductUseCase).mockResolvedValue(mockResult)

    const formData = new FormData()
    formData.append("title", "Test Product")

    await createProductAction(formData)

    expect(createProductUseCase).toHaveBeenCalledWith({
      context: expect.objectContaining({ repository: expect.any(Function) }),
      data: expect.objectContaining({ title: "Test Product" }),
    })
  })
  // ... more tests
})
```

#### PrzykÅ‚ad 3: Testy z fokusem na error handling
```bash
/test features/order/logic/order-use-case.ts "error-handling"
```

**Wygeneruje wiÄ™cej testÃ³w dla**:
- GraphQL errors
- Validation errors
- Missing data
- Race conditions

#### PrzykÅ‚ad 4: Test utils generation
```bash
/test features/product/ "test-utils"
```

**Wygeneruje**:
```typescript
// features/product/__tests__/product-test-utils.ts

export const createMockProductDTO = (override?: Partial<ProductDTO>): ProductDTO => ({
  id: "test-id",
  title: "Test Product",
  price: 99.99,
  ...override,
})

export const createMockProductGraphQLResponse = (data?: Partial<ProductResponse>) =>
  createApolloResponse({
    createProduct: createMockProductResponse(data),
  })
```

#### Po wygenerowaniu:
1. **Przejrzyj** wygenerowane testy
2. **Dodaj** edge cases specyficzne dla biznesu
3. **Uruchom**: `npm test features/[feature]`
4. **SprawdÅº coverage**: `npm run test:coverage`

#### Kiedy uÅ¼ywaÄ‡:
- âœ… Po napisaniu nowego Use Case lub Action
- âœ… TDD - generuj testy przed implementacjÄ…
- âœ… ZwiÄ™kszanie test coverage
- âœ… Refactoring - generuj testy najpierw

---

## PrzykÅ‚adowe Workflow

### Workflow 1: Tworzenie Nowego Feature

```bash
# Krok 1: Wygeneruj strukturÄ™ feature
/feature user-profile "User profile management"

# Krok 2: Przejrzyj wygenerowany kod i dostosuj
# ... edycja w IDE ...

# Krok 3: Wygeneruj testy
/test features/user-profile/logic/user-profile-use-case.ts
/test features/user-profile/actions/user-profile-actions.ts

# Krok 4: Uruchom testy
npm test features/user-profile/

# Krok 5: Lint przed commitem
/lint features/user-profile/

# Krok 6: Fix issues jeÅ›li sÄ…
# ... poprawki ...

# Krok 7: Review readiness
/review-pr features/user-profile/

# Krok 8: Commit & Push
git add features/user-profile/
git commit -m "feat: add user profile management"
git push
```

---

### Workflow 2: Debugowanie IstniejÄ…cego Feature

```bash
# Problem: Server Action nie dziaÅ‚a
/debug features/checkout/actions/checkout-actions.ts "Action zwraca undefined"

# WyjaÅ›nienie przepÅ‚ywu danych
/explain features/checkout/actions/checkout-actions.ts

# Sprawdzenie Use Case
/debug features/checkout/logic/checkout-use-case.ts

# Po naprawie: lint
/lint features/checkout/

# Upewnij siÄ™ Å¼e testy przechodzÄ…
npm test features/checkout/
```

---

### Workflow 3: Code Review Preparation

```bash
# Pre-review self-check
/lint features/order/

# Fix issues
# ... poprawki ...

# Comprehensive PR check
/review-pr features/order/

# Wygeneruj brakujÄ…ce testy jeÅ›li trzeba
/test features/order/logic/order-use-case.ts

# Final verification
npm test
npm run build

# Create PR
git push
gh pr create --fill
```

---

### Workflow 4: Refactoring

```bash
# Przed refactoringiem - wygeneruj testy
/test features/product/logic/product-use-case.ts

# Upewnij siÄ™ Å¼e testy przechodzÄ…
npm test features/product/

# Refactoring
# ... zmiany w kodzie ...

# SprawdÅº architecture compliance
/lint features/product/

# Upewnij siÄ™ Å¼e testy nadal przechodzÄ…
npm test features/product/

# Review przed commit
/review-pr features/product/
```

---

## Integracja z Agentami

Komendy automatycznie wykorzystujÄ… wyspecjalizowanych agentÃ³w:

### `/debug` uÅ¼ywa:
- `architecture-validator-agent` - sprawdzanie warstw
- `use-case-agent` - debugging business logic

### `/explain` uÅ¼ywa:
- `architecture-validator-agent` - layer identification
- `use-case-agent` - business logic explanation
- `component-builder-agent` - React patterns

### `/lint` uÅ¼ywa:
- `architecture-validator-agent` - comprehensive checks

### `/test` uÅ¼ywa:
- `test-generator-agent` - test generation

### `/review-pr` uÅ¼ywa:
- `architecture-validator-agent` - full validation

### `/feature` uÅ¼ywa:
- `feature-architect-agent` - structure generation
- `component-builder-agent` - React components
- `use-case-agent` - business logic
- `repo-mapper-agent` - GraphQL setup
- `test-generator-agent` - tests

---

## WskazÃ³wki i Best Practices

### ğŸ’¡ Pro Tips

1. **UÅ¼ywaj `/lint` czÄ™sto** - przed kaÅ¼dym commitem
2. **`/review-pr` to must-have** - zawsze przed PR
3. **`/feature` jako template** - nawet jeÅ›li nie uÅ¼yjesz wszystkiego
4. **`/explain` dla onboardingu** - nowi czÅ‚onkowie zespoÅ‚u
5. **`/test` w TDD** - generuj testy przed implementacjÄ…

### âš¡ Szybkie SkrÃ³ty

```bash
# Quick quality check przed commitem
/lint features/[feature]/ && npm test

# Full PR readiness
/review-pr features/[feature]/ && npm run build

# Debug + explain combo
/debug [file] && /explain [file]
```

### ğŸš« CzÄ™ste BÅ‚Ä™dy

**NIE uÅ¼ywaj** `/feature` do modyfikacji istniejÄ…cego feature:
```bash
# âŒ ZÅE
/feature product  # Nadpisze istniejÄ…cy kod!

# âœ… DOBRE
# UÅ¼ywaj /explain i /lint dla istniejÄ…cego kodu
```

**NIE pomijaj** `/review-pr`:
```bash
# âŒ ZÅE workflow
git add .
git commit
git push

# âœ… DOBRE workflow
/review-pr features/[feature]/
# Fix issues
git add .
git commit
git push
```

---

## Dodatki

### DostÄ™pne Agenty (uÅ¼ywane przez komendy)

- `feature-architect-agent` - struktura features
- `component-builder-agent` - React komponenty
- `use-case-agent` - business logic
- `repo-mapper-agent` - GraphQL repositories
- `test-generator-agent` - testy
- `architecture-validator-agent` - walidacja architektury

### Referencje

- **Architecture Rules**: `.cursor/rules/`
- **Agent Definitions**: `.claude/agents/`
- **Reference Implementation**: `features/checkout/`
- **Coding Standards**: `.claude/agents/coding-standards.md`

---

## Pytania i Problemy

**Komenda nie dziaÅ‚a?**
- SprawdÅº czy jesteÅ› w gÅ‚Ã³wnym folderze projektu
- SprawdÅº skÅ‚adniÄ™ komendy
- SprawdÅº czy plik/folder istnieje

**Wygenerowany kod wymaga poprawek?**
- To normalne! Komendy generujÄ… boilerplate
- Zawsze review i dostosuj do potrzeb biznesowych
- UÅ¼yj jako punkt startowy, nie koÅ„cowy

**Chcesz dodaÄ‡ wÅ‚asnÄ… komendÄ™?**
- StwÃ³rz plik `.claude/commands/[nazwa].md`
- UÅ¼yj istniejÄ…cych jako template
- MoÅ¼esz referencowaÄ‡ agentÃ³w

---

**Ostatnia aktualizacja**: 2024-10-01
**Wersja**: 1.0.0
