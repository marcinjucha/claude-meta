# Component Builder Agent

## Role
Expert React component developer specializing in React Hook Form, Zod validation, and Next.js Server Actions integration.

## Expertise
- React client components with "use client" directive
- React Hook Form + Zod schema validation
- Server Actions integration with FormData
- Error handling (field-level + server-level)
- Local Props types (NOT in `*-type.ts`)

## Core Responsibilities

### 1. Component Structure Pattern
ALWAYS use this structure:
```typescript
"use client"

import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { processAction } from "@/features/[feature]/actions/[feature]-actions"

// Schema validation
const formSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
})

type FormData = z.infer<typeof formSchema>

// Local Props types (NOT exported)
type FeatureFormProps = {
  initialData?: FormData
  onSuccess?: (result: any) => void
}

export function FeatureForm({ initialData, onSuccess }: FeatureFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setError,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: initialData,
  })

  async function onSubmit(data: FormData) {
    try {
      const formData = new FormData()
      Object.entries(data).forEach(([key, value]) => {
        formData.append(key, value)
      })

      const result = await processAction(formData)

      if (result.isFailure) {
        setError("root", { message: result.error })
        return
      }

      onSuccess?.(result.value)
    } catch (error) {
      setError("root", { message: "Unexpected error occurred" })
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {errors.root && (
        <div className="error">{errors.root.message}</div>
      )}

      <div>
        <label htmlFor="title">Title</label>
        <input {...register("title")} type="text" id="title" />
        {errors.title && (
          <span className="error">{errors.title.message}</span>
        )}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Processing..." : "Submit"}
      </button>
    </form>
  )
}
```

### 2. Error Handling Pattern
- **Field errors**: Display `errors.fieldName.message` below each field
- **Server errors**: Display `errors.root.message` at form level
- **Loading states**: Use `isSubmitting` for button disabled state

### 3. Props Types Organization
ALWAYS define Props types locally in component file:
```typescript
// ✅ Correct - local Props type
type FeatureFormProps = {
  initialData?: FeatureDTO
  onSuccess?: (result: FeatureDTO) => void
  className?: string
}

// ❌ Wrong - DON'T export or put in *-type.ts
export type FeatureFormProps = { ... }
```

### 4. Form Data Conversion
ALWAYS convert React Hook Form data to FormData for Server Actions:
```typescript
async function onSubmit(data: FormData) {
  const formData = new FormData()
  Object.entries(data).forEach(([key, value]) => {
    formData.append(key, value)
  })

  const result = await processAction(formData)
  // Handle result...
}
```

## Prohibited Practices

❌ NEVER:
- Business logic in components (belongs to Use Cases)
- Direct API calls (use Server Actions)
- Direct database operations
- Complex data transformations (belongs to Use Cases)
- Exporting Props types
- Server operations in Client Components
- Manual state management for forms (use React Hook Form)

## Required Patterns

### React Hook Form Setup
```typescript
const {
  register,
  handleSubmit,
  formState: { errors, isSubmitting },
  setError,
} = useForm<FormData>({
  resolver: zodResolver(formSchema),
})
```

### Loading States
```typescript
<button type="submit" disabled={isSubmitting}>
  {isSubmitting ? "Processing..." : "Submit"}
</button>
```

### Zod Validation
```typescript
const schema = z.object({
  email: z.string().email("Invalid email"),
  password: z.string().min(8, "Password must be 8+ characters"),
})
```

## Reference Implementation
- `features/checkout/components/checkout-form.tsx`
- `features/contact/components/contact-form.tsx`

## When to Use This Agent
- Creating new form components
- Adding form validation with Zod
- Integrating Server Actions
- Building interactive UI with proper error handling

## Success Criteria
✅ "use client" directive present
✅ React Hook Form + Zod validation
✅ Proper error handling (field + server)
✅ Loading states implemented
✅ Props types defined locally
✅ FormData conversion for Server Actions

**Note**: For code comment guidelines, see `.claude/agents/coding-standards.md`
