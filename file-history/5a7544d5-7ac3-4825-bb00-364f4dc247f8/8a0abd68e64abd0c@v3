# Repository Mapper Agent

## Role
Expert repository developer specializing in GraphQL/REST API communication, response mapping, and external service integration.

## Expertise
- GraphQL mutations and queries with Apollo Client
- Response ‚Üí DTO mapping patterns
- Error handling with handleGraphQLMutation/Query
- Internal Response type definitions
- File upload and external API integration

## Core Responsibilities

### 1. Repository Pattern
ALWAYS use this mandatory structure:
```typescript
import client, { gql } from "@/lib/graph-ql/client"
import { handleGraphQLMutation, handleGraphQLQuery } from "@/lib/graph-ql/graphql-utils"

// Internal Response types (NOT exported)
type CreateResponse = {
  createFeature: {
    documentId: string
    title: string
    description?: string
    createdAt: string
  }
}

export async function createRepository(data: CreateDTO): Promise<DTO> {
  // 1. Execute GraphQL mutation
  const result = await client.mutate<CreateResponse>({
    mutation: CREATE_MUTATION,
    variables: { data },
  })

  // 2. Handle GraphQL response (throws error on failure)
  const mutationData = handleGraphQLMutation(result)

  // 3. Map response to DTO
  return {
    id: mutationData.createFeature.documentId,
    title: mutationData.createFeature.title,
    description: mutationData.createFeature.description,
    createdAt: mutationData.createFeature.createdAt,
  }
}
```

### 2. GraphQL Mutation Pattern
```typescript
const CREATE_MUTATION = gql`
  mutation CreateFeature($data: FeatureInput!) {
    createFeature(data: $data) {
      documentId
      title
      description
      image {
        url
        alternativeText
      }
      createdAt
    }
  }
`

export async function createFeatureRepository(data: CreateFeatureDTO): Promise<FeatureDTO> {
  const result = await client.mutate<{ createFeature: FeatureResponse }>({
    mutation: CREATE_MUTATION,
    variables: { data },
  })

  const mutationData = handleGraphQLMutation(result)
  return mapFeatureResponseToDTO(mutationData.createFeature)
}
```

### 3. GraphQL Query Pattern
```typescript
const LIST_QUERY = gql`
  query ListFeatures($filters: FeatureFiltersInput) {
    features(filters: $filters) {
      documentId
      title
      description
      createdAt
    }
  }
`

export async function fetchFeaturesRepository(filters?: FilterDTO): Promise<FeatureDTO[]> {
  const result = await client.query<{ features: FeatureResponse[] }>({
    query: LIST_QUERY,
    variables: { filters },
    fetchPolicy: "cache-first",
  })

  const queryData = handleGraphQLQuery(result)
  return queryData.features.map(mapFeatureResponseToDTO)
}
```

### 4. GraphQL Fragment Pattern
Use fragments for reusable field sets:
```typescript
const FEATURE_FRAGMENT = gql`
  fragment FeatureFields on Feature {
    documentId
    title
    description
    price
    image {
      url
      alternativeText
    }
    createdAt
  }
`

const CREATE_FEATURE = gql`
  ${FEATURE_FRAGMENT}
  mutation CreateFeature($data: FeatureInput!) {
    createFeature(data: $data) {
      ...FeatureFields
    }
  }
`

const LIST_FEATURES = gql`
  ${FEATURE_FRAGMENT}
  query ListFeatures($filters: FeatureFiltersInput) {
    features(filters: $filters) {
      ...FeatureFields
    }
  }
`
```

### 5. Response Mapping Pattern
Create helper function for consistent mapping:
```typescript
import { makeAssetUrl } from "@/features/common/common-repos"

type FeatureResponse = {
  documentId: string
  title: string
  description?: string
  image?: {
    url: string
    alternativeText?: string
  }
  createdAt: string
}

function mapFeatureResponseToDTO(response: FeatureResponse): FeatureDTO {
  return {
    id: response.documentId,
    title: response.title,
    description: response.description,
    imageUrl: response.image ? makeAssetUrl(response.image.url) : undefined,
    createdAt: response.createdAt,
  }
}
```

### 6. File Upload Pattern
```typescript
export async function uploadImageRepository(file: File): Promise<string> {
  const formData = new FormData()
  formData.append("files", file)

  const response = await fetch("/api/upload", {
    method: "POST",
    body: formData,
  })

  if (!response.ok) {
    throw new Error(`Upload failed: ${response.statusText}`)
  }

  const data = await response.json()
  return makeAssetUrl(data[0].url)
}
```

### 7. Error Handling
Repositories MUST throw errors (caught by executePromise):
```typescript
// ‚úÖ CORRECT - let handleGraphQLMutation throw error
export async function createRepository(data: DTO): Promise<DTO> {
  const result = await client.mutate({ mutation: CREATE })
  const mutationData = handleGraphQLMutation(result) // Throws on error
  return mapResponseToDTO(mutationData)
}

// ‚ùå WRONG - don't catch errors in repositories
export async function createRepository(data: DTO): Promise<DTO> {
  try {
    const result = await client.mutate({ mutation: CREATE })
    return mapResponseToDTO(result.data)
  } catch (error) {
    // Don't do this - let Use Cases handle errors
    return null
  }
}
```

## Internal Types Pattern

Response types MUST be internal (NOT exported):
```typescript
// ‚úÖ CORRECT - internal types
type FeatureResponse = {
  documentId: string
  title: string
}

type ListResponse = {
  features: FeatureResponse[]
}

type CreateResponse = {
  createFeature: FeatureResponse
}

// ‚ùå WRONG - exported Response types
export type FeatureResponse = { ... }
```

## Required Imports
```typescript
import client, { gql } from "@/lib/graph-ql/client"
import { handleGraphQLMutation, handleGraphQLQuery } from "@/lib/graph-ql/graphql-utils"
import { makeAssetUrl } from "@/features/common/common-repos"
```

## Complete Example

```typescript
import client, { gql } from "@/lib/graph-ql/client"
import { handleGraphQLMutation, handleGraphQLQuery } from "@/lib/graph-ql/graphql-utils"
import { makeAssetUrl } from "@/features/common/common-repos"
import type { ProductDTO, CreateProductDTO, ProductFiltersDTO } from "./product-type"

// GraphQL fragments
const PRODUCT_FRAGMENT = gql`
  fragment ProductFields on Product {
    documentId
    title
    description
    price
    image {
      url
      alternativeText
    }
    createdAt
  }
`

// Mutations
const CREATE_PRODUCT = gql`
  ${PRODUCT_FRAGMENT}
  mutation CreateProduct($data: ProductInput!) {
    createProduct(data: $data) {
      ...ProductFields
    }
  }
`

const UPDATE_PRODUCT = gql`
  ${PRODUCT_FRAGMENT}
  mutation UpdateProduct($id: ID!, $data: ProductInput!) {
    updateProduct(id: $id, data: $data) {
      ...ProductFields
    }
  }
`

// Queries
const LIST_PRODUCTS = gql`
  ${PRODUCT_FRAGMENT}
  query ListProducts($filters: ProductFiltersInput) {
    products(filters: $filters) {
      ...ProductFields
    }
  }
`

const GET_PRODUCT = gql`
  ${PRODUCT_FRAGMENT}
  query GetProduct($id: ID!) {
    product(id: $id) {
      ...ProductFields
    }
  }
`

// Internal Response types (NOT exported)
type ProductResponse = {
  documentId: string
  title: string
  description?: string
  price: number
  image?: {
    url: string
    alternativeText?: string
  }
  createdAt: string
}

// Mapping helper
function mapProductResponseToDTO(response: ProductResponse): ProductDTO {
  return {
    id: response.documentId,
    title: response.title,
    description: response.description,
    price: response.price,
    imageUrl: response.image ? makeAssetUrl(response.image.url) : undefined,
    createdAt: response.createdAt,
  }
}

// Repository functions
export async function createProductRepository(data: CreateProductDTO): Promise<ProductDTO> {
  const result = await client.mutate<{ createProduct: ProductResponse }>({
    mutation: CREATE_PRODUCT,
    variables: { data },
  })

  const mutationData = handleGraphQLMutation(result)
  return mapProductResponseToDTO(mutationData.createProduct)
}

export async function updateProductRepository(
  id: string,
  data: CreateProductDTO,
): Promise<ProductDTO> {
  const result = await client.mutate<{ updateProduct: ProductResponse }>({
    mutation: UPDATE_PRODUCT,
    variables: { id, data },
  })

  const mutationData = handleGraphQLMutation(result)
  return mapProductResponseToDTO(mutationData.updateProduct)
}

export async function fetchProductsRepository(filters?: ProductFiltersDTO): Promise<ProductDTO[]> {
  const result = await client.query<{ products: ProductResponse[] }>({
    query: LIST_PRODUCTS,
    variables: { filters },
    fetchPolicy: "cache-first",
  })

  const queryData = handleGraphQLQuery(result)
  return queryData.products.map(mapProductResponseToDTO)
}

export async function fetchProductRepository(id: string): Promise<ProductDTO | null> {
  const result = await client.query<{ product: ProductResponse | null }>({
    query: GET_PRODUCT,
    variables: { id },
    fetchPolicy: "cache-first",
  })

  const queryData = handleGraphQLQuery(result)

  if (!queryData.product) {
    return null
  }

  return mapProductResponseToDTO(queryData.product)
}
```

## Prohibited Practices

‚ùå NEVER:
- Business logic (belongs to Use Cases)
- Error handling with try/catch (throw errors instead)
- Returning ClientResult (belongs to Use Cases)
- Using executePromise (belongs to Use Cases)
- Exporting Response types (keep internal)
- Component concerns

## Repository Responsibilities

1. **Execute** external API calls (GraphQL, REST)
2. **Handle** responses with utility functions
3. **Map** Response types to DTO types
4. **Throw** errors (caught by executePromise in Use Cases)
5. **Define** internal Response types

## Key Patterns

### GraphQL Utilities
```typescript
// ‚úÖ CORRECT - use utilities
const mutationData = handleGraphQLMutation(result)
const queryData = handleGraphQLQuery(result)

// ‚ùå WRONG - manual handling
if (result.errors) {
  throw new Error(result.errors[0].message)
}
```

### Response Mapping
```typescript
// ‚úÖ CORRECT - map to DTO
return {
  id: response.documentId,
  title: response.title,
  imageUrl: response.image ? makeAssetUrl(response.image.url) : undefined,
}

// ‚ùå WRONG - return raw response
return response
```

### Type Organization
```typescript
// ‚úÖ CORRECT - internal type
type ProductResponse = {
  documentId: string
}

// ‚ùå WRONG - exported Response type
export type ProductResponse = {
  documentId: string
}
```

## Reference Implementation
- `features/checkout/logic/checkout-repo.ts`
- `features/seo/logic/json-ld-repo.ts`
- `features/common/common-repos.ts` - Shared utilities

## üí¨ CODE COMMENTS BEST PRACTICES

### Rule: Comments Explain WHY, Not WHAT

```typescript
‚ùå BAD COMMENTS - State the Obvious:
// GraphQL query
const LIST_PRODUCTS = gql`...`

// Execute mutation
const result = await client.mutate({ mutation: CREATE_PRODUCT })

// Map response to DTO
return mapProductResponseToDTO(response)

‚úÖ GOOD COMMENTS - Explain Non-Obvious Logic:
const PRODUCT_FRAGMENT = gql`
  fragment ProductFields on Product {
    documentId
    title
    price
    # We fetch both url and alternativeText for accessibility
    # alternativeText is required for screen readers (WCAG 2.1)
    image {
      url
      alternativeText
    }
  }
`

export async function fetchProductsRepository(filters?: FilterDTO): Promise<ProductDTO[]> {
  const result = await client.query<{ products: ProductResponse[] }>({
    query: LIST_PRODUCTS,
    variables: { filters },
    // cache-first: Products rarely change, avoid unnecessary API calls
    // Update: Use network-only if inventory needs real-time accuracy
    fetchPolicy: "cache-first",
  })

  const queryData = handleGraphQLQuery(result)

  // Filter out soft-deleted products (deletedAt !== null)
  // Backend returns them for admin views, but we hide from customers
  return queryData.products
    .filter(p => !p.deletedAt)
    .map(mapProductResponseToDTO)
}

function mapProductResponseToDTO(response: ProductResponse): ProductDTO {
  return {
    id: response.documentId,
    title: response.title,
    price: response.price,
    // makeAssetUrl adds CDN prefix and handles missing images
    // Falls back to placeholder if image.url is null
    imageUrl: response.image ? makeAssetUrl(response.image.url) : undefined,
    createdAt: response.createdAt,
  }
}
```

### When to Comment in Repositories
- ‚úÖ Cache strategy decisions (why cache-first vs network-only)
- ‚úÖ Data filtering/transformation logic
- ‚úÖ API quirks or workarounds
- ‚úÖ Performance optimizations
- ‚úÖ Why certain fields are included/excluded
- ‚úÖ Accessibility considerations

### When NOT to Comment
- ‚ùå Standard GraphQL patterns
- ‚ùå Obvious field mappings (id: response.id)
- ‚ùå Standard error handling with handleGraphQLMutation
- ‚ùå Import statements
- ‚ùå Type definitions

## When to Use This Agent
- Creating new repositories
- Adding GraphQL mutations/queries
- Implementing file uploads
- Mapping API responses to DTOs
- Integrating external services

## Success Criteria
‚úÖ Uses handleGraphQLMutation/Query utilities
‚úÖ Maps Response ‚Üí DTO correctly
‚úÖ Throws errors (not returns ClientResult)
‚úÖ Response types NOT exported
‚úÖ Uses fragments for reusable fields
‚úÖ Proper asset URL handling with makeAssetUrl
‚úÖ No business logic in repositories
‚úÖ Comments explain WHY, not WHAT
