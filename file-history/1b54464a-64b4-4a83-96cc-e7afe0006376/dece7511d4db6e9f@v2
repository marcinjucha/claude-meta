---
description: SwiftGen-based localization system using L10n constants, naming conventions, and localized string management patterns
---

# Digital Shelf iOS Localization Rules

## When to use this guide

**Keywords that trigger this:**
- text, string, label, message
- translate, localize
- button text, error message
- hardcoded string
- multi-language

**Natural examples:**
- "add error message for failed login"
- "button needs proper text label"
- "this string should be localized"
- "need translation for 'Save' button"
- "show message to user about upload"

---

## Overview
This app uses SwiftGen to generate localized strings from `Localized.strings` into a type-safe `L10n` enum structure. All user-facing text must be localized using this system.

## Key Naming Convention

### Structure Pattern
- **Prefix**: Always start with `L10n.`
- **Namespacing**: Use PascalCase for each namespace segment separated by dots
- **Hierarchy**: Follow the UI hierarchy and feature organization

### Naming Format
```swift
L10n.FeatureName.ComponentName.elementDescription
```

### Examples
```swift
// ✅ Good examples
L10n.Home.Menu.makeOfflineAvailable
L10n.Home.Menu.sendFeedback
L10n.Home.Menu.changeStore
L10n.StoreList.errorMessage
L10n.UpdateFlow.AislePreview.handednessTitle
L10n.Login.Form.emailPlaceholder
L10n.Settings.Account.logoutButton

// ❌ Bad examples
L10n.makeOfflineAvailable        // Missing namespace
L10n.home.menu.make_offline      // Wrong case, underscores
L10n.HomeMenuMakeOffline         // Too flat, no dots
```

## Hierarchical Organization

### Primary Level: Feature/Screen Names
- `Home` - Home screen and related components
- `Login` - Authentication flows
- `StoreList` / `StoreSelection` - Store selection features
- `Settings` - Settings and preferences
- `ScanHistory` - Scan history functionality
- `UpdateFlow` - Shelf update workflows
- `VideoUpdateFlow` - Video capture workflows

### Secondary Level: Component/Section Names
- `Menu` - Menu components
- `Form` - Form-related elements
- `List` - List views and items
- `Dialog` - Dialogs and modals
- `Alert` - Alert messages
- `Navigation` - Navigation elements

### Tertiary Level: Specific Elements
- `title` - Titles and headers
- `subtitle` - Subtitles and descriptions
- `button` - Button labels
- `placeholder` - Input placeholders
- `message` - Messages and body text
- `errorMessage` - Error text
- `successMessage` - Success text

## Content Guidelines

### Text Content Rules
1. **User-facing text**: All text visible to users must be localized
2. **Fallback values**: Always provide English fallback in SwiftGen format
3. **Context**: Keys should be descriptive of their purpose and location
4. **Consistency**: Use consistent terminology across similar UI elements

### String Content Best Practices
```swift
// ✅ Descriptive and clear
L10n.Home.Menu.makeOfflineAvailable // "Make offline available"
L10n.Login.Form.emailValidationError // "Please enter a valid email address"

// ❌ Too generic or unclear
L10n.Home.button1 // "Button"
L10n.error // "Error"
```

## Implementation Rules

### SwiftUI Usage
```swift
// ✅ Correct usage in SwiftUI
Text(L10n.Home.Menu.makeOfflineAvailable)
Button(L10n.Common.save) { /* action */ }

// ❌ Hardcoded strings
Text("Make offline available")
Button("Save") { /* action */ }
```

### Parameterized Strings
For strings with dynamic content, use SwiftGen's parameter support:
```swift
// In Localized.strings:
"home.itemCount" = "Items (%d)";

// Generated code:
static func itemCount(_ p1: Int) -> String {
    L10n.tr("Localized", "home.itemCount", p1, fallback: "Items (%d)")
}

// Usage:
Text(L10n.Home.itemCount(items.count))
```

### Pluralization
Use `.stringsdict` for proper pluralization:
```swift
// For proper plural handling
L10n.Home.itemCount(count) // Handles "1 item" vs "2 items"
```

## File Organization

### Primary Files
- `Localized.strings` - Main localization file with all translations
- `Strings.swift` - Generated by SwiftGen, contains L10n enum
- `Localizable.stringsdict` - For pluralization rules (when needed)

### Workflow
1. Add new keys to `Localized.strings` following the naming convention
2. Run SwiftGen to regenerate `Strings.swift`
3. Use the generated `L10n` constants in SwiftUI code
4. Never commit hardcoded user-facing strings

## Common Patterns

### Menu Items
```swift
L10n.Home.Menu.makeOfflineAvailable
L10n.Home.Menu.sendFeedback
L10n.Home.Menu.changeStore
L10n.Settings.Menu.about
L10n.Settings.Menu.logout
```

### Form Elements
```swift
L10n.Login.Form.emailPlaceholder
L10n.Login.Form.passwordPlaceholder
L10n.Login.Form.submitButton
L10n.Profile.Form.saveButton
```

### Error Messages
```swift
L10n.Login.Error.invalidCredentials
L10n.Network.Error.connectionFailed
L10n.StoreList.Error.loadingFailed
```

### Navigation and Headers
```swift
L10n.Home.Navigation.title
L10n.Settings.Navigation.title
L10n.Profile.Section.accountTitle
```

## Quality Assurance

### Pre-commit Checks
- [ ] No hardcoded user-facing strings in SwiftUI views
- [ ] All L10n keys follow the naming convention
- [ ] SwiftGen regeneration successful
- [ ] New strings added to `Localized.strings`

### Code Review Guidelines
- Verify all user-facing text uses L10n constants
- Check naming convention compliance
- Ensure descriptive, context-appropriate key names
- Validate fallback values are appropriate

## Migration Strategy

### For Existing Hardcoded Strings
1. Identify the appropriate namespace based on feature/component
2. Create descriptive key following the convention
3. Add entry to `Localized.strings`
4. Regenerate with SwiftGen
5. Replace hardcoded string with L10n constant

### Example Migration
```swift
// Before:
Text("Make offline available")

// After:
// 1. Add to Localized.strings:
"home.menu.makeOfflineAvailable" = "Make offline available";

// 2. Regenerate Strings.swift with SwiftGen

// 3. Use in code:
Text(L10n.Home.Menu.makeOfflineAvailable)
```

## Tools and Commands

### SwiftGen Regeneration
```bash
# Regenerate localization constants
swiftgen config run --config swiftgen.yml
```

### Validation Tools
- Use SwiftLint rules to catch hardcoded strings
- Implement build-time checks for missing localization keys
- Regular audits of `TODO` comments for localization

---

**Remember**: Localization is not just translation—it's about creating a globally accessible user experience. Always consider context, cultural sensitivity, and technical constraints when designing localized content.