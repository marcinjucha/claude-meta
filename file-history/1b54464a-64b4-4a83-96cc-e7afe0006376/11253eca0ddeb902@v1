---
description: Presentation layer patterns - state management, user interactions, async operations, UI integration, child views, and testing
---
# Presentation Layer Essentials - Digital Shelf iOS

## üîë Keywords & Usage

**Use this rule when you write:**
- "view", "screen", "UI", "presentation layer"
- "state", "action", "feature", "store"
- "user interaction", "button", "form"
- "loading state", "error handling", "navigation"
- "child view", "modal", "alert", "sheet"
- "publisher", "effect", "async operation"

**Example prompts:**
- "Create user profile screen"
- "Add loading state to this view"
- "Handle button tap with async operation"
- "Design state for this screen"
- "Show error alert when API fails"
- "Add child feature for settings modal"

---

## üö® Critical TCA Rules

### 1. @Dependency + TaskGroup = CRASH
```swift
// ‚ùå CRASH - Never access @Dependency inside TaskGroup
@Dependency(\.apiClient) var apiClient
withThrowingTaskGroup { group in
    group.addTask { try await self.apiClient.fetch() } // CRASH!
}

// ‚úÖ ALWAYS capture @Dependency before TaskGroup
let apiClient = self.apiClient
withThrowingTaskGroup { group in
    group.addTask { try await apiClient.fetch() } // Safe
}
```

**Why It Crashes:**
TaskGroup creates isolated execution context where `@Dependency` property wrappers cannot access dependency container.

### 2. TCA Must-Haves Checklist
- ‚úÖ `@ObservableState` on all State structs
- ‚úÖ `BindingReducer()` first in reducer body
- ‚úÖ Individual `CancelID` for each publisher
- ‚úÖ Use Publishers pattern (NOT TaskGroup in TCA)
- ‚úÖ `makeWithDeps` factory for components with @Dependency

---

## ‚ö° Core TCA Patterns

### State Design Essentials

**How to Design State:**
1. **Start with data properties** - What data does the screen display?
   - Collections: Use `IdentifiedArrayOf<Item>` (not `[Item]`)
   - Selection: Store IDs, not full objects
2. **Add UI state** - What changes during user interaction?
   - `isLoading`, `errorMessage`, `selectedItemId`
3. **Add child features** - Use `@Presents` for optional children
   - `@Presents var alert: AlertState<Action.Alert>?`
4. **Add computed properties** - Derive state, don't store duplicates
   - `var selectedItem: Item? { items[id: selectedItemId] }`
5. **Mark everything** - Add `@ObservableState` and `Equatable`

**Template:**
```swift
@ObservableState
struct State: Equatable {
    // 1. Data
    var items: IdentifiedArrayOf<Item> = []
    var selectedItemId: Item.ID?

    // 2. UI state
    var isLoading = false
    var errorMessage: String?

    // 3. Child features
    @Presents var alert: AlertState<Action.Alert>?

    // 4. Computed
    var selectedItem: Item? { items[id: selectedItemId] }
}
```

### Action Organization

**How to Design Actions:**
1. **View lifecycle** - Add `viewAppeared`, `onDisappear`
2. **User actions** - One action per user interaction
   - Name with "Tapped", "Changed", "Selected"
3. **System responses** - Add success/failure cases
   - `dataLoaded([Item])`, `loadingFailed(String)`
4. **Publisher updates** - Use for real-time data
   - `itemsUpdated([Item])` (use keypaths in `receive`)
5. **Child actions** - If using child features
   - `case child(ChildFeature.Action)`
6. **Delegation** - For parent communication
   - `case delegate(DelegateAction)`

**Template:**
```swift
enum Action {
    // 1. Lifecycle
    case onAppear
    case onDisappear

    // 2. User
    case itemTapped(Item.ID)
    case refreshButtonTapped

    // 3. System
    case itemsLoaded([Item])
    case loadingFailed(String)

    // 4. Publishers
    case itemsUpdated([Item])

    // 5. Delegation
    case delegate(DelegateAction)

    enum DelegateAction {
        case itemSelected(Item)
    }
}
```

### Reducer Composition (Critical Order!)

```swift
var body: some ReducerOf<Self> {
    BindingReducer()           // 1. ALWAYS first!

    Scope(state: \.child, action: \.child) {  // 2. Child features
        ChildFeature()
    }

    Reduce { state, action in  // 3. Main logic last
        // Handle actions
    }
}
```

**Why Order Matters:**
`BindingReducer()` must come first to handle SwiftUI bindings properly.

---

## üîÑ Publisher Pattern (Preferred in TCA)

### Standard Setup
```swift
case .onAppear:
    return .merge(
        .publisher {
            useCase.dataPublisher.map(Action.dataUpdated)
        }
        .cancellable(id: CancelID.data),

        .publisher {
            useCase.networkStatus.map(Action.networkStatusChanged)
        }
        .cancellable(id: CancelID.network)
    )

case .onDisappear:
    return .merge(
        .cancel(id: CancelID.data),
        .cancel(id: CancelID.network)
    )
```

**Publisher Best Practices:**
- Use unique `CancelID` for each publisher
- Cancel in `onDisappear` to prevent leaks
- Map publisher values to actions
- Use `.merge()` for multiple effects

### CancelID Pattern
```swift
private enum CancelID {
    case data, network, timer, search
}
```

---

## ‚è±Ô∏è Effect Patterns

### One-Time Effect
```swift
case .loadData:
    state.isLoading = true
    return .run { send in
        do {
            let data = try await useCase.fetchData()
            await send(.dataLoaded(data))
        } catch {
            await send(.loadingFailed(error.localizedDescription))
        }
    }
```

### Debounced Search
```swift
case .searchQueryChanged(let query):
    state.searchQuery = query
    guard !query.isEmpty else {
        return .cancel(id: CancelID.search)
    }

    return .run { send in
        try await clock.sleep(for: .milliseconds(300))
        await send(.performSearch(query))
    }
    .cancellable(id: CancelID.search, cancelInFlight: true)
```

### Timer Effect
```swift
case .startTimer:
    return .run { send in
        for await _ in clock.timer(interval: .seconds(1)) {
            await send(.timerTick)
        }
    }
    .cancellable(id: CancelID.timer)

case .stopTimer:
    return .cancel(id: CancelID.timer)
```

---

## üé® Presentation (Alerts, Sheets, Dialogs)

### Standard Pattern
```swift
@ObservableState
struct State: Equatable {
    @Presents var alert: AlertState<Action.Alert>?
    @Presents var sheet: SheetFeature.State?
    @Presents var confirmationDialog: ConfirmationDialogState<Action.ConfirmationDialog>?
}

enum Action {
    case alert(PresentationAction<Alert>)
    case sheet(PresentationAction<SheetFeature.Action>)
    case confirmationDialog(PresentationAction<ConfirmationDialog>)

    case showDeleteConfirmation

    enum Alert: Equatable {}
    enum ConfirmationDialog: Equatable {
        case confirmDelete
    }
}

// Show confirmation
case .showDeleteConfirmation:
    state.confirmationDialog = ConfirmationDialogState {
        TextState("Delete Item")
    } actions: {
        ButtonState(action: .confirmDelete) { TextState("Delete") }
        ButtonState(role: .cancel) { TextState("Cancel") }
    }
    return .none

// Handle response
case .confirmationDialog(.presented(.confirmDelete)):
    return .run { send in await send(.deleteButtonTapped) }
```

---

## üñºÔ∏è SwiftUI Integration

### View Pattern
```swift
struct FeatureView: View {
    @Bindable var store: StoreOf<FeatureStore>

    var body: some View {
        List(store.items) { item in
            ItemRowView(item: item)
                .onTapGesture {
                    store.send(.itemTapped(item.id))
                }
        }
        .searchable(text: $store.searchQuery)
        .alert($store.scope(state: \.alert, action: \.alert))
        .onAppear { store.send(.onAppear) }
        .onDisappear { store.send(.onDisappear) }
    }
}
```

**SwiftUI Best Practices:**
- Use `@Bindable var store` (NOT `WithViewStore` - outdated)
- Send actions for user interactions
- Use `$store` for two-way bindings
- Always handle `onAppear`/`onDisappear`

---

## üß™ Testing Pattern

### Standard Setup
```swift
@MainActor
final class FeatureStoreTests: XCTestCase {
    let useCase = FeatureUseCaseSpy()  // Mock

    lazy var sut = TestStoreOf<FeatureStore>(
        initialState: FeatureStore.State()
    ) {
        FeatureStore(useCase: useCase)
    }
}
```

### Testing with Dependencies
```swift
let store = TestStore(initialState: Feature.State()) {
    Feature()
} withDependencies: {
    $0.apiClient = .mock
    $0.uuid = .constant(UUID())
    $0.continuousClock = TestClock()
}
```

**Testing Rules:**
- Use `@MainActor` for TCA feature tests
- Mock ALL dependencies
- Use lazy var for TestStore (never in `setUp()`)
- Test complete user workflows

---

## üéØ Advanced Patterns

### Form Validation
```swift
@ObservableState
struct State: Equatable {
    var email = ""
    var password = ""

    var emailError: String? {
        email.isEmpty ? nil : (email.isValidEmail ? nil : "Invalid email")
    }

    var isFormValid: Bool {
        emailError == nil && !email.isEmpty && password.count >= 8
    }
}
```

### Child Feature Integration
```swift
@ObservableState
struct State: Equatable {
    var child: ChildFeature.State = .init()
}

enum Action {
    case child(ChildFeature.Action)
}

var body: some ReducerOf<Self> {
    Scope(state: \.child, action: \.child) {
        ChildFeature()
    }

    Reduce { state, action in
        switch action {
        case .child:
            return .none  // Handle if needed
        }
    }
}
```

### ViewAction Pattern (Complex Features)
```swift
@Reducer
struct LoginFeature {
    enum Action: ViewAction {
        case alert(PresentationAction<Alert>)
        case loginResponse(Result<AuthResponse, Error>)
        case view(View)

        enum Alert: Equatable {}
        enum View: BindableAction {
            case binding(BindingAction<State>)
            case loginButtonTapped
        }
    }
}
```

---

## üö® Common Pitfalls

### Problem: TCA not updating UI
- ‚úÖ Check: `@ObservableState` on State struct?
- ‚úÖ Check: `BindingReducer()` first in reducer body?
- ‚úÖ Check: Using `@Bindable var store` in SwiftUI?

### Problem: Memory leaks
- ‚úÖ Solution: Cancel publishers in `onDisappear`
- ‚úÖ Check: Using unique `CancelID` for each publisher?

### Problem: App crashes with @Dependency
- ‚úÖ Solution: Capture dependency before TaskGroup
- ‚úÖ Pattern: `let dep = self.dep` then use in TaskGroup

---

## ‚úÖ TCA Implementation Checklist

### State
- [ ] `@ObservableState` annotation
- [ ] All properties `Equatable`
- [ ] Computed properties for derived state
- [ ] `@Presents` for child features

### Reducer
- [ ] `BindingReducer()` first
- [ ] `Scope()` for child features
- [ ] `Reduce()` for main logic last

### Effects
- [ ] Unique `CancelID` for each publisher
- [ ] Cancel effects in `onDisappear`
- [ ] Handle all async responses

### Testing
- [ ] `makeWithDeps` factory exists
- [ ] All dependencies mocked
- [ ] TestStore uses lazy var

---

## üéØ Quick Reference

**State**: `@ObservableState` + `Equatable` + computed properties
**Actions**: Lifecycle + User + System + Publishers + Child + Delegate
**Reducer**: `BindingReducer()` ‚Üí `Scope()` ‚Üí `Reduce()`
**Publishers**: Unique `CancelID` + cancel in `onDisappear`
**View**: `@Bindable var store` + send actions
**Critical**: Capture `@Dependency` before TaskGroup!

**Remember: TCA is predictable state management through unidirectional data flow.**
