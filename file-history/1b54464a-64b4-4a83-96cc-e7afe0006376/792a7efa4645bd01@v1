---
description: Code organization, where to put logic, separating responsibilities, structuring features, and dependency patterns
---
# Code Organization & Structure - Digital Shelf iOS

## üîë Keywords & Usage

**Use this rule when you write:**
- "structure", "organize", "layers", "architecture"
- "where to put this logic", "service or use case"
- "repository", "business logic", "presentation"
- "file structure", "code organization"
- "separate concerns", "responsibilities"

**Example prompts:**
- "How should I structure this feature?"
- "Where should I put this business logic?"
- "Should I use Service or Use Case here?"
- "Organize code for route filtering"
- "Where does this calculation belong?"

---

## üèóÔ∏è Core Architecture

### Four-Layer Clean Architecture
**Presentation ‚Üí Business ‚Üí Data ‚Üí Models**

Each layer depends only on layers below it, never above:
```
Presentation (SwiftUI + TCA)
    ‚Üì depends on
Business (Use Cases + Services)
    ‚Üì depends on
Data (Repositories)
    ‚Üì depends on
Models (Domain Entities)
```

**Why This Matters:**
- **Testability**: Each layer can be tested independently
- **Maintainability**: Changes in one layer don't cascade to others
- **Flexibility**: Replace implementations without breaking dependents

---

## üì¶ Layer Responsibilities

### Models Layer (Domain)
- **Purpose**: Pure business entities without dependencies
- **Contents**: `Route`, `User`, `Store`, `UploadStatus`
- **Location**: `DigitalShelf/Models/`
- **Rules**:
  - Must be `Equatable` for TCA state
  - Add `Codable` only if serialized
  - Include `.sample()` factory for tests

### Repository Layer (Data Access)
- **Purpose**: Single-responsibility data operations
- **Pattern**: One repository per data source
- **Types**:
  - **Data Repository**: Database CRUD (GRDB)
  - **Network Repository**: API calls (HttpService)
  - **Shared Repository**: In-memory state shared across features
- **Critical Rule**: Repositories NEVER depend on other repositories
- **Location**: `DigitalShelf/Screens/[Feature]/Repository/`

**Why Repositories Don't Depend on Each Other:**
Prevents circular dependencies and keeps responsibilities clear. If you need multiple repositories, use a Service.

### Service Layer (Business Logic)
- **Purpose**: Combines multiple repositories OR complex algorithms
- **When to Use**:
  - Combining 2+ repositories (prevents dependency cycles)
  - Complex business algorithms (badge calculation, data fusion)
  - Domain-specific logic reused across features
- **Examples**:
  - `RouteWithHistoryService` - combines 5 repositories
  - `HomeModeService` - combines 3 repositories + mode creation logic
- **Location**: `DigitalShelf/Services/[Feature]/`

### Use Case Layer (Orchestration)
- **Purpose**: Thin coordination between Services/Repositories and Presentation
- **Responsibilities**:
  - Delegate to Services/Repositories
  - Expose publishers for reactive data
  - Simple data transformations
- **What NOT to Put Here**: Complex algorithms (use Service instead)
- **Location**: `DigitalShelf/Screens/[Feature]/Use Case/`

### Presentation Layer (UI + State)
- **Purpose**: User interface and state management
- **Components**:
  - **Feature Store** (TCA): State + Actions + Reducer
  - **View** (SwiftUI): Layout + Store binding
- **Location**: `DigitalShelf/Screens/[Feature]/Presentation/`

---

## üîÄ Decision Trees

### When to Use Service vs Use Case?

**Step-by-step decision:**

1. **Does it access data?**
   - YES, single source (DB OR API) ‚Üí **Create Repository**
   - YES, multiple sources ‚Üí Go to step 2
   - NO ‚Üí Go to step 3

2. **Need to combine multiple repositories?**
   - YES ‚Üí **Create Service**
   - NO ‚Üí Go to step 3

3. **Is there complex business logic?**
   - YES (algorithms, calculations, filtering) ‚Üí **Create Service**
   - NO (just delegates/coordinates) ‚Üí **Create Use Case**

**Quick Rules:**
```
Repository: Single data source (DB or API)
Service:    Multiple repos OR complex algorithm
Use Case:   Thin orchestration, exposes publishers to TCA
```

**Examples:**
- 2+ repos needed? ‚Üí **Service** (prevents cycles)
- Badge calculation logic? ‚Üí **Service** (algorithm)
- Just coordinate Service ‚Üí Repo? ‚Üí **Use Case** (thin)
- Expose publishers to TCA? ‚Üí **Use Case** (bridge)

---

## üìê Code Organization

### File Structure Pattern
```
Feature/
‚îú‚îÄ‚îÄ Model/           # Domain entities (if feature-specific)
‚îú‚îÄ‚îÄ Repository/      # Data access (DB, API, cache)
‚îú‚îÄ‚îÄ Service/         # Business logic (if needed)
‚îú‚îÄ‚îÄ Use Case/        # Orchestration
‚îî‚îÄ‚îÄ Presentation/    # TCA Feature + SwiftUI View
    ‚îú‚îÄ‚îÄ FeatureStore.swift
    ‚îî‚îÄ‚îÄ FeatureView.swift
```

### Naming Conventions
- **Models**: `Route`, `User`, `UploadStatus`
- **Features**: `RouteListFeature`, `HomeFeature`
- **Views**: `RouteListView`, `HomeView`
- **Use Cases**: `RouteListUseCase`, `HomeUseCase`
- **Repositories**: `RouteDataRepository`, `RouteNetworkRepository`
- **Services**: `RouteWithHistoryService`, `HomeModeService`

### File Organization (Within Classes)
Strict order for consistency:
1. **Static properties/methods**
2. **Instance properties** (public ‚Üí internal ‚Üí private)
3. **Lifecycle** (init, deinit)
4. **Methods** (public ‚Üí internal ‚Üí private)
5. **Extensions with nested types** (separate from main declaration)

---

## üèõÔ∏è SOLID Principles in Practice

### Single Responsibility Principle (SRP)
- **Rule**: Each class has one reason to change
- **Example**: `RouteWithHistoryService` (data fusion) vs `RouteRefreshService` (refresh operations)
- **Decision**: Split when responsibilities become clear, not prematurely

### Dependency Inversion Principle (DIP)
- **Rule**: Depend on abstractions (`@Dependency`), not concretions
- **Pattern**: Use protocols + dependency injection
- **Example**: `@Dependency(\.apiClient)` instead of `let apiClient = HTTPClient()`
- **Critical**: Capture dependencies before TaskGroup (see Critical Rules)

### Interface Segregation Principle (ISP)
- **Rule**: Focused protocols, not monolithic interfaces
- **Example**: `AnyRouteRefreshService` vs `AnyRouteHistoryService` (separate concerns)
- **Balance**: Don't create too many tiny protocols

### Open/Closed Principle (OCP)
- **Rule**: Open for extension, closed for modification
- **Pattern**: Use protocols + dependency injection for flexibility
- **Balance**: Don't over-abstract; keep it simple when possible

### Liskov Substitution Principle (LSP)
- **Rule**: Protocol implementations must honor contracts
- **Example**: All `AnyRepository` implementations behave consistently
- **Practice**: Don't throw unexpected errors or change behavior significantly

---

## üîß Dependency Injection Pattern

### Standard Pattern
```swift
// Production code - uses @Dependency
final class HomeUseCase: AnyHomeUseCase {
    @Dependency(\.modeService) private var modeService
    @Dependency(\.storeRepository) private var storeRepository

    init() {} // No manual injection
}

// Test code - uses makeWithDeps factory
#if DEBUG
extension HomeUseCase {
    static func makeWithDeps(
        modeService: AnyModeService,
        storeRepository: StoreRepository
    ) -> HomeUseCase {
        withDependencies {
            $0.modeService = modeService
            $0.storeRepository = storeRepository
        } operation: { HomeUseCase() }
    }
}
#endif
```

**Why This Pattern:**
- Production code stays clean (no test dependencies)
- Tests can inject mocks easily
- `#if DEBUG` keeps factories out of release builds

### Advanced Dependency Registration
```swift
enum MyDependencyKey: DependencyKey {
    static var liveValue: MyDependencyProtocol = MyDependency()
    #if DEBUG
    static var testValue: MyDependencyProtocol = MyDependency()
    #endif
}

extension DependencyValues {
    var myDependency: MyDependencyProtocol {
        get { self[MyDependencyProtocol.self] }
        set { self[MyDependencyProtocol.self] = newValue }
    }
}
```

---

## üéØ Best Practices

### Composition over Inheritance
- **Prefer**: Protocol composition + dependency injection
- **Avoid**: Deep class hierarchies
- **Example**: Service combining repositories vs inheriting from base service

### Fail Fast Principle
- **Use**: Guard statements for invalid state
- **Example**: `guard let storeId = storeRepository.activeStoreId else { return }`
- **Balance**: Graceful degradation for user-facing features

### Don't Repeat Yourself (DRY)
- **Extract**: Common logic to services, extensions, utilities
- **Timing**: Wait for clear patterns before abstracting
- **Balance**: Don't abstract too early (3+ uses = abstract)

### Meaningful Comments Only
- **Comment WHY**: Complex algorithms, race conditions, business decisions
- **Don't Comment WHAT**: Code should be self-documenting
- **Examples**:
  - ‚úÖ `// Group by 15-second windows to prevent duplicate uploads in same session`
  - ‚ùå `// Set loading state to true` (obvious)

---

## ‚úÖ Architecture Checklist

### Before Starting Feature
- [ ] Identified which layers are needed (Models, Repo, Service, UseCase, TCA)
- [ ] Decided Service vs Use Case based on decision tree
- [ ] Planned repository responsibilities (no cross-repo dependencies)
- [ ] Designed data flow (publishers vs one-time effects)

### During Implementation
- [ ] Each component has single responsibility
- [ ] Dependencies use `@Dependency` + `makeWithDeps`
- [ ] Repositories don't depend on other repositories
- [ ] Services combine multiple repositories OR handle complex algorithms
- [ ] Use Cases are thin orchestration layers

### Before Committing
- [ ] File organization follows standard order
- [ ] Naming conventions followed
- [ ] No obvious comments (only WHY, not WHAT)
- [ ] `makeWithDeps` wrapped in `#if DEBUG`
- [ ] Tests verify architecture boundaries

---

## üéØ Quick Reference

**Architecture**: Clean Architecture (4 layers)
**Dependency Rule**: Higher layers depend on lower layers only
**Repository Rule**: Never depend on other repositories
**Service vs UseCase**: Service = multiple repos OR complex logic; UseCase = orchestration
**Dependency Injection**: `@Dependency` + `makeWithDeps` pattern
**Comments**: Only WHY, never WHAT

**Remember: Clarity in architecture leads to maintainable code.**
