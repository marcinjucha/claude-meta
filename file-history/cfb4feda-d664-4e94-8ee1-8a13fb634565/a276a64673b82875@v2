# Services - CLAUDE.md

Services to warstwa infrastruktury aplikacji zawierająca niezależne komponenty do obsługi API, bazy danych, analytics, storage, camera i innych systemowych funkcjonalności.

## Kluczowe Komponenty

### 1. ShelfAccountStorage (`AccountStorage/ShelfAccountStorage.swift`)

**Odpowiedzialność:**
- Zarządzanie sesją użytkownika (login/logout)
- Przechowywanie API token (Keychain)
- Fetch store configuration + offline cache
- Fetch products dla sklepu
- Clearowanie danych przy logout

**Kluczowe Properties:**
```swift
let isLoggedIn: CurrentValueSubject<Bool, Never>
let products: CurrentValueSubject<[String: Product], Never>
let configInfo: CurrentValueSubject<ConfigInfo?, Never>

var apiToken: String? {  // Keychain storage
    get { secureDataStorage[.apiTokenKey] }
    set {
        secureDataStorage[.apiTokenKey] = newValue
        isLoggedIn.value = newValue != nil
    }
}
```

**Login Flow:**
```swift
func login(email: String, password: String) -> AnyPublisher<Void, Error> {
    // 1. Register device → get API token
    httpService.request(endpoint: RegisterDevice(...))
        .handleEvents { response in
            self.apiToken = response.apiToken
            self.userRepository.setUser(...)
        }
    // 2. Fetch user details
        .flatMap { res in
            httpService.request(endpoint: MeEndpoint(apiToken: res.apiToken))
                .handleEvents { res in
                    self.userRepository.updateUser(id: res.userId, ...)
                }
        }
}
```

**Logout Flow:**
```swift
func logout() async {
    await clear()  // Clear local data first
    guard let apiToken else { return }

    // Notify backend (fire-and-forget)
    try? await httpService.request(endpoint: Logout(apiToken: apiToken))
}

private func clear() async {
    storeRepository.clear()
    appConfigPersistence.clear()
    routeDataRepository.clearRoutes()
    await modulePreviewRepository.removeModulePreviews()
    apiToken = nil
    userRepository.clear()
    dataStorage.clear()
    database.clear()
}
```

**Config Fetch z Offline Fallback:**
```swift
func fetchStoreConfiguration(storeId: Int) -> AnyPublisher<ConfigInfo, Error> {
    httpService.request(endpoint: ConfigEndpoint(...))
        .handleEvents { configInfo in
            // Cache dla offline use
            appConfigPersistence.setConfig(forStore: storeId, config: configInfo)
        }
        .catch { error in
            // Fallback do cached config
            if let cachedConfig = appConfigPersistence.getConfig(forStore: storeId) {
                return Just(cachedConfig).setFailureType(to: Error.self)
            }
            return Fail(error: error)
        }
}
```

**Dependencies:**
```
@Dependency(\.secureStorage)        # Keychain
@Dependency(\.keyValueStorage)      # UserDefaults
@Dependency(\.httpService)          # API calls
@Dependency(\.database)             # GRDB
@Dependency(\.appConfigPersistence) # Config cache
@Dependency(\.storeRepository)      # Active store
@Dependency(\.userRepository)       # User data
```

---

### 2. HTTPService (`HTTPService.swift`)

**Odpowiedzialność:**
- Generic HTTP client dla API calls
- Environment management (production/staging/custom)
- Request/response handling z retry logic
- Error mapping (401, 429, 5xx)
- App compatibility checking

**Core Types:**
```swift
enum HttpEnvironment: Codable {
    case production
    case staging
    case customStaging(String)  // Custom URL
}

enum HttpMethod: String {
    case get, post, patch, put
}

enum HttpHeader {
    case authorization(String)           // Bearer token
    case accept(ContentType)
    case content(ContentType)
    case appVersion(String)
    case appCompatibility(AppCompatibility)  // supported/deprecated/unsupported
    case sdkVersion(String)
    case operatingSystem(String)
    case deviceId(String)
    case cacheControl(CacheControl)
}
```

**Protocol: HttpEndpoint**
```swift
protocol HttpEndpoint {
    var path: String { get }
    var queryItems: [URLQueryItem]? { get }
    var method: HttpMethod { get }
    var headers: [HttpHeader] { get }
}

protocol HasRequestPayload {
    associatedtype RequestPayload: Encodable
    var requestPayload: RequestPayload { get }
}

protocol HasResponsePayload {
    associatedtype ResponsePayload: Decodable
}
```

**Usage Pattern:**
```swift
struct RegisterDevice: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = DeviceInfo
    typealias ResponsePayload = DeviceToken

    let path = "api/v1/device"
    let method: HttpMethod = .post
    let headers: [HttpHeader] = [.content(.json), .accept(.json)]
    let requestPayload: DeviceInfo
}

// Call
httpService.request(endpoint: RegisterDevice(...))
    .sink(receiveCompletion: { ... }, receiveValue: { response in
        print(response.apiToken)
    })
```

**Error Types:**
```swift
enum RequestError: Error {
    case invalid
    case apiTokenMissing
}

struct ResponseError: LocalizedError {
    enum ErrorType {
        case invalidRequest         // 400
        case unauthorized           // 401
        case clientError            // 4xx
        case serverError            // 5xx
        case tooManyRequests        // 429
        case unsupportedAppVersion  // App compatibility check
        case unknown
    }

    let type: ErrorType
    let statusCode: Int
    let error: AnyJson?
    let response: HTTPURLResponse?
}
```

**Retry Logic:**
- Max 3 retries dla server errors (5xx)
- Exponential backoff dla 429 (Too Many Requests)
- `Retry-After` header support

---

### 3. ShelfDatabase (`Database/ShelfDatabase.swift`)

**Odpowiedzialność:**
- GRDB database wrapper
- Reactive publishers dla tables
- Migrations
- In-memory database dla testów

**Setup:**
```swift
final class ShelfDatabase: AppDatabase {
    static var defaultDatabase: ShelfDatabase {
        isUnitTestRunning ? inMemory() : database
    }

    private static let database: ShelfDatabase = {
        let databaseURL = FileManager.default
            .documentDirectory
            .appendingPathComponent("db.sqlite")
        let queue = try DatabaseQueue(path: databaseURL.path)
        return ShelfDatabase(writer: queue)
    }()

    static func inMemory() -> ShelfDatabase {
        let queue = try DatabaseQueue()  // In-memory
        return ShelfDatabase(writer: queue)
    }
}
```

**Reactive Publishers:**
```swift
var uploadSessions: AnyPublisher<[UploadSessionInfo], Error> {
    initializationSubject
        .filter(\.self)
        .flatMap { _ in
            ValueObservation
                .tracking { database -> [UploadSessionInfo] in
                    try UploadSessionInfo.fetchAll(database)
                }
                .publisher(
                    in: self.writer,
                    scheduling: .async(onQueue: .global(qos: .userInitiated))
                )
        }
        .eraseToAnyPublisher()
}
```

**Record Types:**
- `StoreRecord` - stores
- `RouteRecord` - routes
- `RouteAisleRecord` - route aisles
- `SessionRecord` - capture sessions
- `SessionModuleRecord` - captured modules
- `UploadRequestRecord` - upload requests
- `UploadSessionInfo` - upload status
- `ConfigRecord` - store configurations
- `LogRecord` - app logs

**⚠️ Ważne:**
- Publishers używają `ValueObservation` dla reactive updates
- Async scheduling na background queue (`.userInitiated`)
- `initializationSubject` czeka na database setup przed emitowaniem

---

### 4. DigitalShelfAPI (`DigitalShelfAPI/`)

**Struktura:**
```
DigitalShelfAPI/
├── DigitalShelfAPIService.swift        # Main HTTP service implementation
├── GenericAPIResponseError.swift       # Generic error parsing
└── Endpoints/
    ├── EndpointPath.swift              # Type-safe endpoint paths
    ├── RegisterDevice.swift            # POST /api/v1/device
    ├── MeEndpoint.swift                # GET /api/v1/me
    ├── Logout.swift                    # POST /api/v1/logout
    ├── StoresEndpoint.swift            # GET /api/v1/stores
    ├── ConfigEndpoint.swift            # GET /api/v1/config
    ├── AislesEndpoint.swift            # GET /api/v1/aisles
    ├── CreateAisleEndpoint.swift       # POST /api/v1/aisles
    ├── UpdateAisleEndpoint.swift       # PATCH /api/v1/aisles/:id
    ├── ModulesEndpoint.swift           # GET /api/v1/modules
    ├── CreateModuleEndpoint.swift      # POST /api/v1/modules
    ├── UploadModuleImageEndpoint.swift # PUT /api/v1/module/:id/image
    ├── RouteEndpoint.swift             # GET /api/v1/routes
    ├── RouteDetailsEndpoint.swift      # GET /api/v1/routes/:id
    ├── Products.swift                  # GET /api/v1/products
    ├── ProductsStores.swift            # GET /api/v1/product-stores
    └── ... (20+ endpoints total)
```

**EndpointPath Pattern:**
```swift
struct EndpointPath {
    let path: String
    private let isEndpoint: (String, URL) -> Bool  // URL matching

    func isEndpoint(forURL url: URL?) -> Bool {
        guard let url else { return false }
        return isEndpoint(path, url)
    }
}

extension EndpointPath {
    static let registerDevice = EndpointPath(path: "api/v1/device")
    static let aisles = EndpointPath(path: "api/v1/aisles")
    static let modules = EndpointPath(path: "api/v1/modules")
    // ...
}
```

**Endpoint Example:**
```swift
struct CreateAisleEndpoint: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = CreateAisleRequest
    typealias ResponsePayload = AisleResponse

    struct CreateAisleRequest: Encodable {
        let name: String
        let storeId: Int
    }

    struct AisleResponse: Decodable {
        let id: Int
        let name: String
        let createdAt: Date
    }

    let path = "api/v1/aisles"
    let method: HttpMethod = .post
    let headers: [HttpHeader]
    let queryItems: [URLQueryItem]? = nil
    let requestPayload: CreateAisleRequest

    init(apiToken: String, name: String, storeId: Int) {
        self.headers = [
            .authorization(apiToken),
            .content(.json),
            .accept(.json)
        ]
        self.requestPayload = CreateAisleRequest(name: name, storeId: storeId)
    }
}
```

**GenericAPIResponseError:**
```swift
struct GenericAPIResponseError: Decodable {
    let detail: String
    let title: String
    let status: Int

    var errorMessage: String { "\(title): \(detail)" }
}
```

**⚠️ Ważne:**
- Wszystkie endpointy są type-safe structs
- Request/Response payloads jako nested types
- API token przekazywany w constructor (nie globalny state)
- Error handling przez `ResponseError` + `GenericAPIResponseError`

---

## Inne Kluczowe Services

### Analytics (`Analytics/`)
- `AppAnalytics` - analytics facade
- `FirebaseAnalytics` - Firebase integration
- `FirebaseEvent` - event definitions
- `ModeFirebaseEvent` - mode-specific events

### Persistence (`Persistence/`)
- `KeyValueStorage` - UserDefaults wrapper
- `KeychainStorage` - Keychain wrapper (secure)
- `AppConfigPersistence` - config caching
- `StoreRepository` - active store management
- `UserRepository` - user data management

### Upload (`Upload/`)
- `UploadURLSession` - background upload session
- `UploadURLSessionTask` - upload task management
- `ResourceIdentifier` - uploaded resource tracking

### ScanditCaptureManager (`ScanditCaptureManager/`)
- `ScanditCaptureManager` - Scandit SDK integration
- `ShelfScanditCaptureManager` - app-specific wrapper
- `DataCaptureModes` - barcode/label capture modes

### RealityKit (`RealityKit/`)
- `ARKitController` - AR session management
- `FocusEntity` - AR focus indicator
- `BarcodeDetector` - AR barcode detection
- Animacje i constraints dla AR entities

### Device (`DeviceMotionTracker/`)
- `DeviceMotionTracker` - CoreMotion integration
- `ShelfDeviceMotionTracker` - app-specific tracker
- Orientation i motion tracking

---

## Wzorce i Best Practices

### 1. Dependency Injection Pattern

```swift
// Service z @Dependency
final class ShelfAccountStorage: AccountStorage {
    @Dependency(\.httpService) private var httpService
    @Dependency(\.database) private var database
    // ...
}

// Registration w DependencyValues
extension DependencyValues {
    var accountStorage: AccountStorage {
        get { self[AccountStorageKey.self] }
        set { self[AccountStorageKey.self] = newValue }
    }
}
```

### 2. Protocol-Based Design

```swift
// Protocol
protocol AccountStorage {
    var isLoggedIn: CurrentValueSubject<Bool, Never> { get }
    var apiToken: String? { get set }

    func login(email: String, password: String) -> AnyPublisher<Void, Error>
    func logout() async
}

// Implementation
final class ShelfAccountStorage: AccountStorage {
    // ...
}

// Fake dla testów
final class FakeAccountStorage: AccountStorage {
    // ...
}
```

### 3. Endpoint Pattern

```swift
// 1. Define endpoint struct
struct MyEndpoint: HttpEndpoint, HasRequestPayload, HasResponsePayload {
    typealias RequestPayload = MyRequest
    typealias ResponsePayload = MyResponse

    let path: String
    let method: HttpMethod
    let headers: [HttpHeader]
    let requestPayload: MyRequest
}

// 2. Call
httpService.request(endpoint: MyEndpoint(...))
    .sink { completion in /* ... */ }
    receiveValue: { response in /* ... */ }
```

### 4. Reactive Publishers z GRDB

```swift
var records: AnyPublisher<[Record], Error> {
    ValueObservation
        .tracking { database in
            try Record.fetchAll(database)
        }
        .publisher(in: writer, scheduling: .async(onQueue: .global()))
        .eraseToAnyPublisher()
}
```

### 5. Offline-First z Fallback

```swift
func fetchData() -> AnyPublisher<Data, Error> {
    networkCall()
        .handleEvents { data in
            cache.save(data)  // Cache success
        }
        .catch { error in
            if let cached = cache.load() {
                return Just(cached).setFailureType(to: Error.self)
            }
            return Fail(error: error)
        }
}
```

## Typowe Błędy i Pitfalls

### ❌ NIE rób tego:

```swift
// 1. Hardcoded API token
struct MyEndpoint: HttpEndpoint {
    let headers = [.authorization("hardcoded-token")]  // ❌
}

// 2. Blocking main thread w database
func fetchRecords() -> [Record] {
    try! database.writer.read { db in
        try Record.fetchAll(db)  // ❌ Blocks main thread!
    }
}

// 3. Nie cachowanie config
func fetchConfig() -> AnyPublisher<Config, Error> {
    httpService.request(endpoint: ConfigEndpoint(...))  // ❌ No offline support
}

// 4. Singleton state
class MyService {
    static var shared = MyService()  // ❌ Hard to test
    static var apiToken: String?     // ❌ Global mutable state
}
```

### ✅ Zrób to:

```swift
// 1. Token przez constructor
init(apiToken: String) {
    self.headers = [.authorization(apiToken)]
}

// 2. Async database access
var records: AnyPublisher<[Record], Error> {
    ValueObservation
        .tracking { try Record.fetchAll($0) }
        .publisher(in: writer, scheduling: .async(onQueue: .global()))
}

// 3. Cache + fallback
fetchConfig()
    .handleEvents { cache.save($0) }
    .catch { _ in
        if let cached = cache.load() {
            return Just(cached).setFailureType(to: Error.self)
        }
        return Fail(error: error)
    }

// 4. Dependency Injection
@Dependency(\.myService) var myService  // ✅ Testable
```

## Testing Guidelines

### Service Tests
- Mock dependencies (HTTP, Database)
- Test error handling (network failures, 401, 429, 5xx)
- Test offline fallback logic
- Test publishers emit correct values

**Przykład:**
```swift
func testLoginSuccess() async throws {
    let mockHTTP = MockHTTPService()
    mockHTTP.registerResponse = DeviceToken(apiToken: "test-token")

    let storage = ShelfAccountStorage.makeWithDeps(httpService: mockHTTP)

    let result = try await storage.login(email: "test@example.com", password: "pass").firstAsync()

    XCTAssertEqual(storage.apiToken, "test-token")
    XCTAssertTrue(storage.isLoggedIn.value)
}
```

## Podsumowanie Kluczowych Wzorców

1. **Protocol-Based Services** - `AccountStorage`, `HttpService`, `AppDatabase`
2. **Dependency Injection** - TCA `@Dependency` dla singletons
3. **Type-Safe Endpoints** - structs conforming to `HttpEndpoint`
4. **Reactive Publishers** - GRDB `ValueObservation` + Combine
5. **Offline-First** - network fetch + cache + fallback
6. **Error Mapping** - `ResponseError` + `GenericAPIResponseError`
7. **Environment Switching** - production/staging/custom
8. **Secure Storage** - Keychain dla sensitive data
9. **Background Operations** - async scheduling dla DB i uploads
10. **Testing Support** - in-memory database, mock services
