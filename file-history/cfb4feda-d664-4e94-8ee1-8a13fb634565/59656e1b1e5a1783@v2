# Routes - CLAUDE.md

Routes to moduł zarządzania trasami skanowania (routes) w sklepie. Umożliwia przeglądanie listy tras, wybór trasy, skanowanie aisles i modułów według określonej kolejności, oraz śledzenie postępu.

## Struktura Folderów

```
Routes/
├── Root/                              # Root coordinator
│   ├── Presentation/
│   │   ├── RouteRootStore.swift       # Root reducer - koordynuje nawigację
│   │   └── RouteRootView.swift        # Root view
│   └── Use Case/
│       └── RouteRootUseCase.swift     # Factory dla CameraViewModel
├── RouteList/                         # Lista tras
│   ├── Model/
│   │   └── ShelfScanRoute.swift       # Model trasy
│   ├── Presentation/
│   │   ├── RouteListFeature.swift     # Feature - route list logic
│   │   ├── RouteListView.swift        # View - route list UI
│   │   ├── RouteRow.swift             # Row component
│   │   └── RouteBadge/                # Badge components (NEW, IN_PROGRESS, etc.)
│   └── Use Case/
│       └── RouteListUseCase.swift     # Orchestration między services
├── RouteDetails/                      # Szczegóły trasy
│   ├── Model/
│   │   └── ShelfScanRouteAisle.swift  # Model aisle w route
│   ├── Presentation/
│   │   ├── RouteDetailsFeature.swift  # Feature - route details logic
│   │   └── RouteDetailsView.swift     # View - route details UI
│   ├── Repository/
│   │   ├── RouteAisleListDataRepository.swift    # Local DB access
│   │   └── RouteAisleListNetworkRepository.swift # Network access
│   └── Use Case/
│       ├── RouteDetailsUseCase.swift     # Main use case
│       └── RouteDetailsRowUseCase.swift  # Row-specific logic
├── Repository/                        # Shared repositories
│   ├── RouteDataRepository.swift      # Local DB - GRDB reactive
│   ├── RouteNetworkRepository.swift   # API calls
│   └── RouteSharedRepository.swift    # Shared state
├── Services/                          # Business services
│   ├── RouteWithHistoryService.swift  # Łączy routes + upload history
│   └── RouteRefreshService.swift      # Periodic refresh
├── Model/                             # Domain models
│   ├── Route.swift
│   ├── RouteAisle.swift
│   └── RouteAisleModule.swift
└── Common/
    └── RouteProgressView.swift        # Progress indicator component
```

## Architektura

### Flow Navigation

```
RouteListView (lista tras)
    ↓ onRouteRowTapped
RouteDetailsView (szczegóły trasy - lista aisles)
    ↓ onAisleTapped
UpdateFlowAislePreviewFeature (podgląd aisle)
    ↓ navigateToModule
UpdateFlowCaptureFeature (capture modułu)
    ↓ capture + approve
UpdateFlowSummaryFeature (podsumowanie)
    ↓ approve
Back to RouteDetailsView
```

**Nawigacja:**
- `RouteRootStore` koordynuje całą nawigację przez `@Dependency(\.routeNavigation)`
- Push destinations: `.routeDetails`, `.aislePreview`, `.updateFlowCaptureView`, `.updateFlowSummary`
- Optional features: `offlineAvailability`, `review`, `recapture`

### Kluczowe Wzorce

#### 1. Service Pattern - RouteWithHistoryService

**Cel:** Łączy dane z wielu źródeł (routes + upload history + network status) w jeden reactive stream.

```swift
protocol AnyRouteWithHistoryService {
    func routePublisher(forId id: Int) -> AnyPublisher<Route, Never>
    func routesPublisher() -> AnyPublisher<[Route], Never>
}
```

**Implementacja:**
- Kombinuje `routeDataRepository.routesPublisher` + `historyRepository.todayUploadHistoryPublisher` + `networkStatusMonitorService.statusPublisher`
- Filtruje history items w 15-sekundowym oknie czasowym od ostatniego uploadu
- Grupuje po module i zachowuje tylko najnowszy upload per module
- Wzbogaca Route o captured state, badge, upload status

**Dependencies:**
```
RouteWithHistoryService
├── @Dependency(\.routeDataRepository)         # GRDB reactive publisher
├── @Dependency(\.historyDataRepository)       # Upload history
├── @Dependency(\.localAislesRepository)       # Aisles data
├── @Dependency(\.routeSharedRepository)       # Shared invalidation signal
└── @Dependency(\.networkStatusMonitorService) # Network status
```

**⚠️ Ważne:**
- Service używa `.share()` dla shared publishers - nie tworzy multiple subscriptions
- History processing: 15-second time window + group by module + keep most recent
- `routeSharedRepository.didChange` trigguje refresh całego flow

#### 2. Use Case Orchestration Pattern

**RouteListUseCase** - orkiestracja między `RouteWithHistoryService` + `RouteRefreshService`:

```swift
protocol AnyRouteListUseCase {
    var routesPublisher: AnyPublisher<[Route], Never> { get }
    var networkStatus: AnyPublisher<NetworkStatus, Never> { get }
    var storeChangeLoadingState: AnyPublisher<Bool, Never> { get }

    func initialize()
    func fetchRoutes() async
    func retryUploadingRoutes(_ routes: [Route])
}
```

**Implementacja:**
- `initialize()` → startuje `refreshService.startPeriodicRefresh()`
- `fetchRoutes()` → async call do `refreshService.fetchRoutes()`
- `retryUploadingRoutes()` → wywołuje `UploadSessionHandler.shared.reupload(requestId:)`
- Publishers przekazują dane z services do feature'ów

**⚠️ Dependency Injection:**
- Use case przyjmuje `reuploadRouteAisleModules` closure w konstruktorze (testability)
- Default init używa `UploadSessionHandler.shared`

#### 3. TCA Features Pattern

**RouteRootStore** - Root Coordinator:

```swift
@ObservableState
struct State: Equatable {
    var routeList: RouteListFeature.State = .init()
    var routeDetails: RouteDetailsFeature.State?      // Optional - push
    var offlineAvailability: OfflineAvailabilityFeature.State?
    var aislePreview: UpdateFlowAislePreviewFeature.State?
    var capture: UpdateFlowCaptureFeature.State?
    var summary: UpdateFlowSummaryFeature.State?
    var review: UpdateFlowModuleReviewFeature.State?
    var recapture: UpdateFlowRecaptureFeature.State?
}
```

**Navigation Flow:**
```swift
case .routeList(.onRouteRowTapped(let route)):
    state.routeDetails = .init(route: route)
    navigation.push(destination: .routeDetails)

case .routeDetails(.navigateToSelectedAisle(let aisle)):
    state.aislePreview = .init(aisle: aisle)
    navigation.push(destination: .aislePreview)

case .aislePreview(.navigateToModule(let model)):
    state.capture = UpdateFlowCaptureFeature.State(
        aisle: model.aisle,
        cameraViewModel: useCase.makeCameraViewModel(),
        moduleOrder: model.moduleOrder,
        exportOptions: exportOptions
    )
    navigation.push(destination: .updateFlowCaptureView)
```

**⚠️ Cleanup Pattern:**
```swift
case .capture(.onDisappear) where navigation.isPoppedFromStack(.updateFlowCaptureView):
    state.capture = nil  // Clear state when popped from stack
```

**RouteListFeature** - Reactive List:

```swift
case .initialize:
    return .merge(
        .send(.reloadList),
        .publisher {
            useCase.storeChangeLoadingState.map(Action.storeChangeLoadingStateChanged)
        }.cancellable(id: Cancel.store),
        .publisher {
            useCase.networkStatus.map(Action.updateNetworkStatus)
        }.cancellable(id: Cancel.network)
    )

case .onAppear:
    return .publisher {
        useCase.routesPublisher.map(Action.updateRoutes)
    }.cancellable(id: Cancel.list, cancelInFlight: true)

case .onDisappear:
    return .cancel(id: Cancel.list)
```

**⚠️ Multiple Publishers Pattern:**
- `.initialize` merguje 3 publishers (reloadList + store state + network status)
- `.onAppear` subscribuje tylko routes publisher
- ZAWSZE cancel w `.onDisappear`

**RouteDetailsFeature** - Details with PassthroughSubject:

```swift
private let actionSubject = PassthroughSubject<RouteDetailsFeature.Action, Never>()

case .onAppear:
    return .publisher {
        useCase.routePublisher(forId: state.route.id)
            .map { Action.updateRoute($0) }
            .merge(with: actionSubject)  // External actions injection
    }.cancellable(id: Cancel.publishers)
```

**⚠️ PassthroughSubject Pattern:**
- `actionSubject` pozwala na injection actions z zewnątrz (np. z background tasks)
- Merged z głównym publisher dla reactive updates

#### 4. Repository Pattern

**RouteDataRepository** - GRDB reactive:

```swift
protocol RouteDataRepository {
    var routesPublisher: AnyPublisher<[Route], Never> { get }
    func fetchRoutes(for storeId: Int) async throws -> [Route]
}
```

**RouteNetworkRepository** - API calls:

```swift
protocol RouteNetworkRepository {
    func fetchRoutes(for storeId: Int) async throws -> [Route]
}
```

**RouteSharedRepository** - Invalidation signal:

```swift
protocol RouteSharedRepository {
    var didChange: AnyPublisher<Void, Never> { get }
    func notifyChange()
}
```

**⚠️ Data Flow:**
1. Network fetch → updates DB
2. DB change → triggers `routesPublisher`
3. `RouteSharedRepository.notifyChange()` → manual invalidation

## Domain Models

### Route
```swift
struct Route: Equatable, Identifiable {
    let id: Int
    let name: String
    let aisles: [RouteAisle]
    let capturedAisles: Int
    let lastCapture: Date?
    let resetDate: Date?
    let badge: RouteBadge?
    let uploadStatus: UploadStatus?
    var isComplete: Bool { aisles.allSatisfy(\.isComplete) }
    var hasPendingUploads: Bool { /* ... */ }
}
```

### RouteAisle
```swift
struct RouteAisle: Equatable, Identifiable {
    let id: Int
    let name: String
    let modules: [RouteAisleModule]
    let capturedModules: Int
    let order: Int
    var isComplete: Bool { modules.allSatisfy(\.isComplete) }
}
```

### RouteAisleModule
```swift
struct RouteAisleModule: Equatable, Identifiable {
    let id: Int
    let name: String
    let uploadRequestId: String?
    let uploadStatus: UploadStatus?
    let capturedAt: Date?
    var isComplete: Bool { capturedAt != nil }
}
```

### RouteBadge
```swift
enum RouteBadge: String {
    case new = "NEW"
    case inProgress = "IN_PROGRESS"
    case lastCaptured = "LAST_CAPTURED"
}
```

## Kluczowe Zależności

```
RouteRootStore
├── @Dependency(\.routeNavigation)
├── @Dependency(\.storeRepository)
├── AnyRouteRootUseCase (constructor, default = RouteRootUseCase())
├── AnyRouteListUseCase (constructor, default = RouteListUseCase())
├── AnyRouteDetailsUseCase (constructor, default = RouteDetailsUseCase())
└── ShelfScanCaptureExportOptions (constructor)

RouteListFeature
└── AnyRouteListUseCase (constructor - REQUIRED)

RouteListUseCase
├── @Dependency(\.networkStatusMonitorService)
├── @Dependency(\.routeWithHistoryService)
├── @Dependency(\.routeRefreshService)
└── @Dependency(\.storeRepository)

RouteWithHistoryService
├── @Dependency(\.routeDataRepository)
├── @Dependency(\.historyDataRepository)
├── @Dependency(\.localAislesRepository)
├── @Dependency(\.routeSharedRepository)
└── @Dependency(\.networkStatusMonitorService)

RouteDetailsFeature
├── @Dependency(\.routeNavigation)
├── @Dependency(\.uuid)
└── AnyRouteDetailsUseCase (constructor - REQUIRED)

RouteDetailsUseCase
├── @Dependency(\.routeWithHistoryService)
└── @Dependency(\.routeAisleListDataRepository)
```

## Testing Guidelines

### Presentation Layer (TCA Features)
- Mock wszystkie use cases i navigation
- Test navigation flow: routeList → routeDetails → aislePreview → capture
- Test publisher subscriptions i cleanup (onAppear/onDisappear)
- Test state updates z reactive publishers

**Przykład:**
```swift
lazy var sut = TestStore(
    initialState: RouteListFeature.State(),
    reducer: { RouteListFeature(useCase: mockUseCase) }
)

func testRouteListSubscription() async {
    await sut.send(.onAppear)
    await sut.receive(\.updateRoutes) { state in
        state.routes = mockRoutes
    }
    await sut.send(.onDisappear)
}
```

### Business Layer (Services + Use Cases)
- Test `RouteWithHistoryService` z REAL repositories
- Mock only external dependencies (Network, DB)
- Test history filtering logic (15-second window, group by module)
- Test periodic refresh in `RouteRefreshService`

## Typowe Błędy i Pitfalls

### ❌ NIE rób tego:
```swift
// 1. Forgetting to cancel publishers
case .onDisappear:
    return .none  // ❌ Publishers continue running!

// 2. Creating multiple publishers without share()
func routesPublisher() -> AnyPublisher<[Route], Never> {
    return routeDataRepository.routesPublisher  // ❌ New subscription każdego razu!
}

// 3. Not handling navigation cleanup
case .routeDetails(.navigateToSelectedAisle):
    // Push to aisle preview
    return .none  // ❌ routeDetails state remains, memory leak!
```

### ✅ Zrób to:
```swift
// 1. ZAWSZE cancel publishers
case .onDisappear:
    return .cancel(id: Cancel.list)

// 2. Use .share() dla shared publishers
private lazy var sharedRoutesPublisher: AnyPublisher<[Route], Never> = {
    routeDataRepository.routesPublisher
        .share()
        .eraseToAnyPublisher()
}()

// 3. Clear state when popped from stack
case .capture(.onDisappear) where navigation.isPoppedFromStack(.updateFlowCaptureView):
    state.capture = nil
```

## Firebase Analytics Events

```swift
// Screen views
analytics.logScreen(name: "route_list")
analytics.logScreen(name: "route_details")

// User actions
analytics.logEvent(name: "route_row_tapped", parameters: ["route_id": routeId])
analytics.logEvent(name: "aisle_tapped", parameters: ["aisle_id": aisleId])
analytics.logEvent(name: "retry_upload", parameters: ["route_id": routeId])
```

## Localization Keys

**Convention:** `L10n.Routes.<Component>.<element>`

```swift
L10n.Routes.List.title                      // "Routes"
L10n.Routes.List.pullToRefresh              // "Pull to refresh"
L10n.Routes.List.retryAll                   // "Retry All Uploads"
L10n.Routes.Details.title                   // "Route Details"
L10n.Routes.Details.lastCaptured            // "Last Captured:"
L10n.Routes.Details.resetDate               // "Reset Date:"
L10n.Routes.Details.capturedAisles          // "Captured Aisles:"
L10n.Routes.Badge.new                       // "NEW"
L10n.Routes.Badge.inProgress                // "IN PROGRESS"
```

## Podsumowanie Kluczowych Wzorców

1. **Service Pattern** - `RouteWithHistoryService` kombinuje multiple sources
2. **Use Case Orchestration** - `RouteListUseCase` orkiestruje między services
3. **Root Coordinator** - `RouteRootStore` zarządza nawigacją całego flow
4. **Reactive Publishers** - GRDB publishers + Combine dla reactive UI
5. **Shared Publishers** - `.share()` dla multiple subscribers
6. **PassthroughSubject** - external action injection w `RouteDetailsFeature`
7. **Navigation Cleanup** - clear state when popped from stack
8. **15-Second Time Window** - history filtering dla accurate progress tracking
