# UpdateFlow Tests - CLAUDE.md

Testy jednostkowe dla komponentów UpdateFlow, obecnie zawierające testy dla `UpdateFlowViewfinderStateHandler`.

## Struktura Folderów

```
UpdateFlow/
└── Model/
    └── UpdateFlowViewfinderStateHandlerTests.swift  # Testy async state transitions
```

## UpdateFlowViewfinderStateHandlerTests

### Cel
Testuje `UpdateFlowViewfinderStateHandler` - komponent zarządzający stanami viewfinder podczas capture flow:
- `.idle` - stan początkowy
- `.capturing(module: String)` - capture w trakcie
- `.successfullyCaptured` - krótka animacja sukcesu po capture

### Wzorzec Testowania - Async State Changes z Combine

**Problem:** Jak testować sekwencję zmian stanu w `@Published` property z opóźnieniami czasowymi?

**Rozwiązanie:** XCTest async/await + XCTWaiter + Combine sink

```swift
func testOnCaptureStarted() async {
    await testStateChanges(expected: [
        .idle,                              // Initial state
        .idle,                              // Remains idle
        .capturing(module: moduleName),     // After delay transitions to capturing
    ]) {
        sut.onCaptureStarted(
            moduleName: moduleName,
            showSuccessfullyCapturedMessage: false
        )
    }
}
```

### Kluczowy Pattern - testStateChanges Helper

```swift
private func testStateChanges(
    expected: [UpdateFlowViewfinderStateHandler.ViewfinderState],
    timeout: TimeInterval = 2.0,
    block: () async -> Void
) async {
    var expected = expected
    let stateChangeExpectation = expectation(description: "")
    stateChangeExpectation.expectedFulfillmentCount = expected.count

    // Subscribe to state changes
    cancellable = sut.$state
        .sink { state in
            if expected.isEmpty {
                XCTFail("Received state \(state), but expected no more state changes")
            } else {
                let expectedValue = expected.removeFirst()
                XCTAssertEqual(state, expectedValue)
                stateChangeExpectation.fulfill()
            }
        }

    // Trigger action
    await block()

    // Wait for all expected state changes
    let result = await XCTWaiter().fulfillment(
        of: [stateChangeExpectation],
        timeout: timeout
    )

    XCTAssertEqual(expected, [], "expected results")  // All consumed
    XCTAssertEqual(result.description, XCTWaiter.Result.completed.description)
}
```

**Jak to działa:**
1. **Setup expectations** - `expectedFulfillmentCount` = liczba oczekiwanych state changes
2. **Subscribe** - `.sink` na `$state` publisher
3. **Verify każdy state** - `removeFirst()` z expected array i compare
4. **Fulfill expectation** - po każdym poprawnym state
5. **Trigger action** - `await block()` wykonuje testowaną operację
6. **Wait** - `XCTWaiter().fulfillment()` czeka na wszystkie expectations (max `timeout`)
7. **Final assertions** - sprawdza czy wszystkie expected states były consumed i czy completed

### Test Cases

**1. testOnCaptureStarted - bez success message**
```swift
Sequence:
.idle → .idle → .capturing(module)

Delays:
- captureStarted: 50ms
```

**2. testOnCaptureStartedWithSuccessfullyCapturedMessage - z success message**
```swift
Sequence:
.idle → .successfullyCaptured → .capturing(module)

Delays:
- successfullyCaptured: 50ms
- captureStarted: 50ms (po successfullyCaptured)
```

### Konfiguracja SUT

```swift
let sut = UpdateFlowViewfinderStateHandler(delays: .init(
    captureStarted: .milliseconds(50),        // Short delay dla testów
    successfullyCaptured: .milliseconds(50)   // Short delay dla testów
))
```

**⚠️ Ważne:**
- Production code używa dłuższych delays (np. 300ms, 800ms)
- Testy używają krótkich delays (50ms) dla szybkiego wykonania
- Delays są injectable przez constructor (dependency injection pattern)

### XCTWaiter.Result Extension

```swift
extension XCTWaiter.Result {
    var description: String {
        switch self {
        case .completed: return "completed"
        case .timedOut: return "timedOut"
        case .incorrectOrder: return "incorrectOrder"
        case .invertedFulfillment: return "invertedFulfillment"
        case .interrupted: return "interrupted"
        @unknown default: return "Error default"
        }
    }
}
```

**Cel:** Lepsze error messages gdy expectations fail.

## Wzorce i Best Practices

### ✅ Dobre Praktyki

1. **Async Test Functions** - `func testXXX() async` dla async operations
2. **XCTWaiter.fulfillment(of:timeout:)** - await expectations zamiast `wait(for:timeout:)`
3. **expectedFulfillmentCount** - dokładna liczba oczekiwanych events
4. **Combine sink** - subscription na `@Published` properties
5. **AnyCancellable storage** - `var cancellable: AnyCancellable?` jako instance variable
6. **Short Delays w testach** - 50ms zamiast production 300ms+
7. **Generic Helper** - `testStateChanges()` reusable dla różnych test cases

### ❌ Antypatterny

1. **❌ Brak timeout** - zawsze ustaw rozsądny timeout (default 2.0s)
2. **❌ Hardcoded delays** - zawsze injectable przez constructor
3. **❌ Multiple assertions na jeden state** - jeden assert per state change
4. **❌ Zapo

mniane cancellation** - zawsze store AnyCancellable
5. **❌ Sync waiter** - nie używaj `wait(for:timeout:)` w async tests

## Testowanie Własnych State Handlers

Jeśli tworzysz podobny state handler, użyj tego wzorca:

```swift
class MyStateHandlerTests: XCTestCase {
    let sut = MyStateHandler(delays: .init(/* short delays */))
    var cancellable: AnyCancellable?

    func testStateTransition() async {
        await testStateChanges(expected: [.stateA, .stateB, .stateC]) {
            sut.triggerAction()
        }
    }

    private func testStateChanges(
        expected: [MyStateHandler.State],
        timeout: TimeInterval = 2.0,
        block: () async -> Void
    ) async {
        // ... implement pattern from UpdateFlowViewfinderStateHandlerTests
    }
}
```

## Podsumowanie

**Kluczowe Wzorce:**
- **Async/Await XCTest** - `async` test functions + `await` operations
- **XCTWaiter + Expectations** - structured async waiting
- **Combine Publisher Testing** - `.sink()` subscription w testach
- **State Sequence Verification** - assert każdy state w kolejności
- **Injectable Delays** - krótkie w testach, długie w production
- **Reusable Test Helpers** - `testStateChanges()` generic helper

**Cel:**
Zapewnić że async state transitions w viewfinder działają poprawnie z odpowiednimi delays i w prawidłowej kolejności.
